[{"title":"关于 text-transform: capitalize 失效的场景与解决方案","date":"2016-10-31T05:39:02.000Z","path":"20161031/text-transform-capitalize-not-working.html","text":"text-transform 是一个可以将文字进行大小写转换或单词首字符大写的 CSS 属性。自从知道了它，我就开始偷懒不在 js 中去在调用相关的转换函数了。 昨天在给多说扩展用户 UA 功能时遇到一个 text-transform: capitalize 失效的问题，经过一番测试，找到了问题的原因。 场景还原根据当时场景，抽取关键 css 属性： .capitalize &#123; text-transform: capitalize&#125;.before:before &#123; content: 'hello'&#125;.after:after &#123; content: 'world'&#125; 现有如下的 HTML，你们猜最终会是什么结果？ &lt;h1 class=\"capitalize\"&gt;hello world&lt;/h1&gt;&lt;h1 class=\"capitalize\"&gt;HELLO WORLD&lt;/h1&gt;&lt;h1 class=\"capitalize before\"&gt;world&lt;/h1&gt;&lt;h1 class=\"capitalize after\"&gt;hello&lt;/h1&gt; 结果： Hello WorldHELLO WORLDHelloworldHelloworld 问题DEMO链接：text-transform: capitalize 失效demo 问题解析通过运行结果可以发现全小写单词组合时，转换没有任何问题，略过。 大写单词组合全大写单词组合，转换失效？真的是这样吗？ 通过查阅相关文档，关于 capitalize 的介绍为：将每个单词的第一个字母转换成大写。看来是我们对它期望太高了，text-transform: capitalize并不能像 lodash 库中的转换函数那样，将全大写的的 AAA 转换成你期望的 Aaa。 含有伪元素这也是我面临到的问题，每个 UA 标签上的 tootip 都是我用伪类模拟的。由于当时伪元素是绝对定位的，在视觉上真的是当作了另外的元素看待。 而在问题 DEMO 中，我们还原了伪元素默认显示的位置：:before 就是在原始内容前追加内容，:after 就是在原始内容后追加内容。由于最后生成的内容之间没有间隙，导致 text-transform 转换时将其当作一个单词。 为了验证我的结论，我在含有伪元素的内容前或后加了个空格： &lt;h1 class=\"capitalize before\"&gt; world&lt;/h1&gt;&lt;h1 class=\"capitalize after\"&gt;hello &lt;/h1&gt; 最后转换成功： Hello WorldHello World DEMO 解决方案虽然找到了问题的原因，但是实际场景中使用伪元素的初衷就是要将一个元素当作多个元素使用，HTML 中加空格会有半个中文字符宽度的空白，也就等于产生了不必要的边距。 做到这里真是感觉不如直接写个 js 转换函数算了。 function capitalize(string) &#123; return string.charAt(0).toUpperCase() + string.substr(1).toLowerCase()&#125; 写出来后忽然发现这段代码完全可以用 CSS 去“实现”。 .capitalize &#123; text-transform: lowercase;&#125;.capitalize:first-letter &#123; text-transform: uppercase;&#125; 上个月旭哥博客有篇很详细的 :first-letter 介绍：张鑫旭：深入CSS :first-letter伪元素及其实例等 其中提到了 :first-letter 和 :before 之间的猫腻，就是说 :first-letter 也生效于 :before 伪元素。不过我测试后发现，当 :before 伪元素设置为绝对定位时，:first-letter将只作用于原始内容。 :first-letter和:before示例demo 利用这个机制，总算可以给自己一个完美的答复了。 .capitalize &#123; text-transform: capitalize&#125;.before &#123; padding-left: 2.5em&#125;.before:before &#123; position: absolute; left: 0; content: 'hello'&#125;.before:first-letter &#123; text-transform: uppercase&#125;.after:after &#123; position: absolute; content: 'world'; text-transform: capitalize&#125; 附加内容在 :before 时，使用 :first-letter + uppercase 解决，如果原始内容有大写，需要再给原标签加 lowercase； 附加内容在 :after 时，给 :after 再加 capitalize。 DEMO End","tags":[{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"},{"name":"text-transform","slug":"text-transform","permalink":"http://imys.net/tags/text-transform/"},{"name":"capitalize","slug":"capitalize","permalink":"http://imys.net/tags/capitalize/"}]},{"title":"使用“队列”解决“插队”业务场景","date":"2016-10-27T09:21:23.000Z","path":"20161027/use-queue-solve-continuous-request.html","text":"为了达到操作变化的实时性，在多选择项的业务场景中，往往点击一次就会发送一次 HTTP 请求。但同时又面临另外一个问题，在连续点击同一个选择项时，就会连续触发针对此项的删除或添加逻辑，进而连续发送 POST 或 DELETE 请求。理想的状态是上一个请求结束后才开始下一个请求，但是网络请求是异步的、请求耗时是不可控的，也就有可能在此项的添加请求未完成前，删除请求先完成了。 我觉得用“插队”来描述这个场景真是再好不过了。 队列既然有人要“插队”，我们就要定义一个规则：先进先出。也就是数据结构中的“队列”了。 javascript 中队列的实现： // 实现1var queue = []// 进队queue.push(1)queue.push(2)queue.push(3)// 出队queue.shift() // 1queue.shift() // 2queue.shift() // 3// 实现2var queue2 = []// 进队queue2.unshift(1)queue2.unshift(2)queue2.unshift(3)// 出队queue2.pop() // 1queue2.pop() // 2queue2.pop() // 3 实践定义一个数组存放每一次点击的 HTTP 请求，此外不管你使用何种开发技术都应该有个发送请求的函数或库，如果是基于 promise 就更好了，这里简单用 XHR 代替。 var requestQueue = []var XHR = function(method, url, param) &#123;&#125; 点击操作的入口函数，先创建请求进队。因为第二次请求必须要在第一次请求完成之后，所以只有队列中仅存在一个请求时才去触发更新。 function myClick(method, url, param) &#123; var len = requestQueue.push(XHR(method, url, param)) if(len === 1) &#123; update() &#125;&#125; 执行的永远是队列中的第一个请求。当一个请求完成后，就出队，队列中剩余的请求依次前进一个位置。如果存在未完成的请求，继续调用更新操作。 function update() &#123; requestQueue[0].then(function(res)&#123; // request success requestQueue.shift() requestQueue.length &amp;&amp; update() &#125;)&#125;","tags":[{"name":"promise","slug":"promise","permalink":"http://imys.net/tags/promise/"},{"name":"request","slug":"request","permalink":"http://imys.net/tags/request/"},{"name":"HTTP","slug":"HTTP","permalink":"http://imys.net/tags/HTTP/"},{"name":"queue","slug":"queue","permalink":"http://imys.net/tags/queue/"},{"name":"数据结构","slug":"数据结构","permalink":"http://imys.net/tags/数据结构/"}]},{"title":"java项目下基于webpack的前端开发环境构建","date":"2016-10-13T06:05:56.000Z","path":"20161013/java-webpack-dev-build.html","text":"标题可能不是很恰当，想不到一个合适的标题来概括我遇到以及解决的问题，暂且这样吧。 项目描述是一个不完全与后端分离的基于 webpack 构建的 Vue 项目。 项目入口是一个 jsp 页面，其中引用了一些 jsp 模版。我想是因为有一些内容需要后端直出到页面上。该页面上固定引用了 webpack 打包好的 css 及 js 文件路径，当然也加了动态参数用于刷新版本更新后的客户端缓存。 可以使用 webpack 命令打包，或是用 webpack --progress --colors --watch 命令启动监听模式动态构建。 这让前端开发环境变的不够友好：监听模式下修改文件后，是需要通过刷新页面获取更改的。好像回到了传统的前端开发环境中。 解决方案由于入口页面是由后端渲染 jsp 生成的，用 html-webpack-plugin 插件生成 html 并注入脚本、样式的法子行不通了。 热替换感觉没戏了，就想办法加个自动刷新吧。 webpack-dev-server开始用 webpack-dev-server 代理后端服务器，可以实现监听更改、实时构建，但由于页面上的页面样式脚本引用与 webpack 构建好的文件路径匹配不上，还是获取不到更改。 var webpack = require('webpack')var webpackDevServer = require('webpack-dev-server')var config = require('./webpack.config')var server = new webpackDevServer(webpack(config), &#123; hot: true, quiet: false, stats: &#123; chunks: false, colors: true &#125;, proxy: &#123; '**': 'http://localhost:8080' &#125;, historyApiFallback: true&#125;)server.listen(3000) 跑了 3000 端口，页面上的文件引用依然是 8080 端口，好像是在后端就写死了。即使是我临时改了 jsp 文件的引用路径，还是需要手动刷新下页面才能获取更改。 browsersync想起了 gulp 时代一直用的 browsersync，用它代理后端服务，监听文件变更并执行 webpack 命令，刷新浏览器。 require('shelljs/global')var bs = require('browser-sync').create()bs.init(&#123; proxy: 'http://localhost:8080'&#125;)bs.watch('./src/**/*.*').on('change', function()&#123; exec('webpack', bs.reload)&#125;) 但这样每次执行 webpack 命令，都相当于全新编译，所以速度很慢。以该项目而言，每次更改后需要等待 6s 才刷新浏览器。 还实验了 gulp + webpack-stream，属于换汤不换药，每次还是全新编译。 今天忽然想到，直接用 webpack 的监听模式启动，在每次编译后刷新浏览器就可以了。监听模式下，只有第一次是全新编译，之后会缓存未变化的模块，所以速度很快。 var webpack = require('webpack')var webpackDevServer = require('webpack-dev-server')var config = require('./webpack.config')var bs = require('browser-sync').create()var compiler = webpack(config)bs.init(&#123; proxy: 'http://localhost:8080'&#125;)compiler.watch(&#123; aggregateTimeout: 300, poll: true &#125;, function(err, stats) &#123; bs.reload() console.log(stats.toString(&#123; chunks: false, colors: true &#125;))&#125;) 监听模式除了命令行启动外，也可以使用 watch 方法调用。之后每次保存文件，只需要 100ms 左右就会刷新浏览器。 感叹一句 如今的前端把多少时间都耗在环境搭建上了~","tags":[{"name":"java","slug":"java","permalink":"http://imys.net/tags/java/"},{"name":"jsp","slug":"jsp","permalink":"http://imys.net/tags/jsp/"},{"name":"webpack","slug":"webpack","permalink":"http://imys.net/tags/webpack/"},{"name":"browsersync","slug":"browsersync","permalink":"http://imys.net/tags/browsersync/"}]},{"title":"如何为Canvas中特定图形绑定事件？","date":"2016-08-08T06:43:38.000Z","path":"20160808/canvas-event.html","text":"Canvas 本身也属于 HTMLElement，自然也是支持各种事件绑定的。但绘制在其中的图形并不作为其子元素存在，这就不能方便的为 Canvas 中的某个特定图形去绑定事件。 我们都知道 js 中的事件委托，将事件绑定到父节点上，待到父节点响应事件时，动态判断当前响应元素为目标子节点时再执行对应的操作。 这个思想同样也可以用在 Canvas 上，只需要为 canvas 元素绑定事件，事件响应时判断当前鼠标位置处于哪个图形之上，执行对应的操作。 isPointInPathcontext.isPointInPath(x, y); 理论上讲，想要知道一个点是否处于一个图形之中，现成的算法应该是有很多了。不过难得 canvas 本身就提供了这样的函数，用来判断一个点是否处于当前路径中。 var c = document.getElementById('canvas');var ctx = c.getContext('2d');ctx.rect(0, 0, 200, 200);console.log(ctx.isPointInPath(50, 100)) // true 就像这样，当你创建一个矩形时，就会产生一个路径，此时就可以调用该方法去判断一个点是否存在于该路径。 产生路径的函数还有其他，比如：lineTo()、clip()、arc()、arcTo() 等。 实现图形的事件绑定先来个简单的饼图吧。 &lt;canvas id=\"c\" width=\"400\" height=\"400\"&gt;&lt;/canvas&gt; var canvas = document.getElementById('c');var ctx = canvas.getContext('2d');var r = canvas.width / 2;ctx.beginPath();ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3'; //蓝色ctx.fill();ctx.beginPath();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336'; //红色ctx.fill();function isInPath (x, y)&#123; ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y);&#125;canvas.addEventListener('click', function(e)&#123; if(isInPath(e.offsetX, e.offsetY)) &#123; console.log('hello') &#125;&#125;) 现在创建一个红蓝拼接的饼图，isInPath 方法判断一个点是否处于蓝色区。理想的结果是只有当鼠标点击区域为蓝色区域时才输出 hello。 但事实确不是如此，示例Demo。无论点击红色还是蓝色区域均会输出 hello，这是怎么回事呢？ 路径既然 isPointInPath(x, y) 的基于路径判断的，那我们就从路径入手。 ctx.arc(r, r, r, 0, Math.PI * 1);ctx.fillStyle = '#2196f3';ctx.fill();ctx.arc(r, r, r, Math.PI * 1, Math.PI * 2);ctx.fillStyle = '#f44336';ctx.fill(); 当我们把画图时的 ctx.beginPath() 去掉后，发现生成的图形变成一个红色的整圆了：示例Demo。 beginPath() 用来重置路径，由于第一个半圆画完路径未重置，第二个半圆就绘制了两条路径。这似乎解释了上个问题的答案。 在 isInPath(x, y) 函数中，由于路径没有重置，所以最终最终判断的不止是 ctx.arc(r, r, r, 0, Math.PI * 1) 这个路径，还有方法外的画红色圆的路径。两个路径加一起自然就是个整圆，所以无论蓝色区还是红色区都会输出。 正确结果function isInPath (x, y)&#123; ctx.beginPath(); ctx.arc(r, r, r, 0, Math.PI * 1); return ctx.isPointInPath(x, y)&#125; 修改 isInPath 函数，加入重置路径，结果正确输出：示例Demo。 实战示例鼠标悬浮显示区块数据的饼图。","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"http://imys.net/tags/canvas/"},{"name":"event","slug":"event","permalink":"http://imys.net/tags/event/"}]},{"title":"VsCode插件：七牛图床工具，写文章更快一步","date":"2016-07-26T01:53:52.000Z","path":"20160726/vscode-extension-qiniu-upload.html","text":"前言一直以来，我都很少在文章中加插图。因为每加一张插图，我都需要先把图片上传到七牛，然后才能获取外链插入文章。 之前写 Markdown 一直是用的 Sublime，直到 Vscode 最近一次更新有了 Tabs 之后，便开始尝试在工作中使用。与最初的预览版相比进步蛮大的，能看到很多 VS 的影子。之前也用过一段时间 Atom，虽然界面挺喜欢，但始终没有原生客户端的流畅感。到底客户端还是微软的强项，Vscode 这方面舒服多了，启动与大文件编辑都不比 Sublime 差。 Vscode 是基于浏览器内核的跨平台编辑器，底层代码大部分都是 TypeScript，当然最终还是会编译为 javascript。这样对于一个前端而言就倍感亲切了，可以轻易的使用自己吃饭的语言去扩展功能。 所以这个七牛图床工具就诞生了。 如何开始插件编写这里还是有必要把这个插件编写过程回顾一下，因为现在可供参考的中文资料实在不多。可以参考这篇文章 vscode编写插件详细过程 来完成插件开发环境部署和创建基本项目。 项目配置以 Javascript 编写插件为例，这里我假设你已经建立了一个基础项目。 就如我们经常在 github 上见到的前端或 Node 项目一样，都有一个 package.json 用于描述项目信息，也可以使用 npm 命令安装你需要的第三方库。此外这个文件中又包含了一些专属于 Vscode 的配置项。 这里不在关注常规的 package.json 配置项，只介绍 Vscode 相关的。 activationEvents插件在何时被激活。 onLanguage:${language}：打开某种格式的文件时 onCommand:${command}：输入某种命令时（Vscode中按F1） onDebug:${type}：调试某种语言类型时 workspaceContains:${toplevelfilename}：当你的工作区包含某种文件时？ *：任何时候，编辑器启动就激活 描述可能有误，对应文档：Activation Events。 contributesContributes 意思是贡献，这个属性中包含的都是可扩展点。 keybindings：绑定按键来执行某个命令 configuration：定义你的插件个性化配置 menus：扩展菜单 commands：用命令名执行某个命令 …… 这四项应该是最常用的，更多：Contribution Points。 OK，有了这些，大概可以为你的插件编写作构思了。 &#123; // 插件何时被激活 \"activationEvents\": [ // 打开一个 Markdown 文件时，插件将被激活 \"onLanguage:markdown\" ], // 插件入口文件 \"main\": \"./extension\", // 扩展点 \"contributes\": &#123; // 按键绑定，当编辑区具有焦点且语言为 markdown 时，按 ctrl+q 执行 extension.qiniu.upload，也可针对 mac 平台独立配置 \"keybindings\": [&#123; \"command\": \"extension.qiniu.upload\", \"key\": \"ctrl+q\", \"mac\": \"ctrl+q\", \"when\": \"editorTextFocus &amp;&amp; editorLangId == 'markdown'\" &#125;], // 插件配置属性，当你想要获取 qiniu 的配置时，以下所有 qiniu.xx 属性将合并于一个对象中 // title 和 description 将作为注释和属性提示分别在默认配置文件和用户配置文件中呈现 \"configuration\": &#123; \"type\": \"object\", \"title\": \"qiniu configuration\", \"properties\": &#123; \"qiniu.enable\": &#123; \"type\": \"boolean\", \"default\": false, \"description\": \"七牛图片上传工具开关\" &#125;, \"qiniu.access_key\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"一个有效的七牛 AccessKey 签名授权。\" &#125;, \"qiniu.secret_key\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"一个有效的七牛 SecretKey 签名授权。\" &#125;, \"qiniu.bucket\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"七牛图片上传空间.\" &#125;, \"qiniu.remotePath\": &#123; \"type\": \"string\", \"default\": \"$&#123;fileName&#125;\", \"description\": \"七牛图片上传路径，参数化命名。\" &#125;, \"qiniu.domain\": &#123; \"type\": \"string\", \"default\": \"\", \"description\": \"七牛图床域名。\" &#125; &#125; &#125; &#125;&#125; 以我的 package.json 为例，描述了以下信息： 当你打开一个 Markdown 文件时，插件将被激活。 执行 ctrl+Q 将启动一个命令，还有一个 when 属性，表示额外的命令激活条件。 因为要上传到七牛，所以需要一些你的七牛用户信息，也就是 configuration，这可以在代码中方便的读取到。 最后我需要以合适的方式获取你想上传的本地图片，以 Markdown 的图片格式写入到你的光标位置。 编码插件的入口文件只有一个，也就是配置中的 &quot;main&quot;: &quot;./extension&quot;。 一个基础的入口文件是这样的： var vscode = require('vscode');// 插件激活时执行function activate(context) &#123; // 注册命令 var disposable = vscode.commands.registerCommand('extension.hello', function () &#123; // 编辑器上方显示一条信息 vscode.window.showInformationMessage('hello!'); &#125;) // 加入释放队列？ context.subscriptions.push(disposable);&#125;exports.activate = activate;// 插件停用时执行function deactivate() &#123;&#125;exports.deactivate = deactivate; 通过这个文件，可以发现 vscode 是个关键的对象，插件能做多少事都取决于这个对象可以提供多少接口支持。 最初我是想通过复制命令实现功能的，也就是用户复制一个图片到编辑器，然后拦截剪贴板拿到图片路径上传、插入文档。事与愿违，Vscode 没有提供这方法的接口支持，见：Issues: Clipboard access through Extensions API。下面提到一个第三方包 node-copy-paste 也仅能访问字符串信息，只好作罢。 Vscode 的接口调用大概分为两类：命令调用：Complex Commands API 和对象方法调用：vscode namespace API。 前者很易用，比如预览 html 的示例： let success = await commands.executeCommand('vscode.previewHtml', Uri.parse('file:///some/path/to/file.html')); 文档的示例是 TypeScript 写的，转换为 ES5 应该是这样： var success = commands.executeCommand('vscode.previewHtml', Uri.parse('file:///some/path/to/file.html')) .then(function(ret)&#123; // success &#125;, function(err) &#123; // error &#125;) 如果能调用一个选择文件的窗口获取本地图片路径最好不过了。可我翻遍了文档，也只找到了一个选择文件夹的命令 vscode.openFolder，简直就是不想让你写的太轻松。 最终只能使用一个输入框来接收本地图片路径，也就是预览图中的效果。 以下是我用到的一些API： // 获取配置文件中的插件配置vscode.workspace.getConfiguration('qiniu')// 显示错误信息vscode.window.showErrorMessage('error')// 显示一个输入框，返回 Promise 对象vscode.window.showInputBox(option)// 编辑文件的函数，参数还是一个函数，这个回调函数的参数才是真正的可以用来增删文字的对象vscode.window.activeTextEditor.edit(function(textEditorEdit) &#123; // 在光标位置插入文本 // textEditorEdit.insert(editor.selection.active, img);&#125;) 最终技术支持其实是 七牛SDK ヾ(･ω･`｡)。具体的代码可以去 Github 上看。 安装打包、发布那篇文章中也提到了，我已经打包放到了 Github 仓库中，就是那个 ·vsix 文件。使用 Ctrl+O 选择插件包就可以安装了，在用户配置文件中加一下你的七牛配置，重启下就能用了，快捷键 ctrl+q。 同时可以通过编辑器左侧插件面板在线搜索 qiniu-upload-image 安装。 文件 -&gt; 首选项 -&gt; 用户设置，在右侧区域编写插件配置覆盖默认配置。配置文件示例如下，参考你的七牛用户信息填写： &#123; \"qiniu.enable\": true, \"qiniu.access_key\": \"xxxxxxxxxxxxx\", \"qiniu.secret_key\": \"xxxxxxxxxxxxx\", \"qiniu.bucket\": \"yourBucket\", \"qiniu.remotePath\": \"$&#123;fileName&#125;\", \"qiniu.domain\": \"http://xxx.xxxxx.com\"&#125; 编辑器中鼠标悬浮会显示属性提示。 Enjoy!","tags":[{"name":"VsCode","slug":"VsCode","permalink":"http://imys.net/tags/VsCode/"},{"name":"qiniu","slug":"qiniu","permalink":"http://imys.net/tags/qiniu/"},{"name":"markdown","slug":"markdown","permalink":"http://imys.net/tags/markdown/"}]},{"title":"对元素特性巧妙利用的一些例子","date":"2016-07-15T01:10:40.000Z","path":"20160715/clever-use-of-elements-feature.html","text":"在一些框架和库中都可见到一些创建一个空元素，通过对该元素特性测试来判定当前运行环境是否支持某种特性的运用。jQuery 也是以此来 support 各种环境，与其通过可被随意修改的 UA 测试环境倒不如直接创建元素测试来的准确。 我们可利用元素本身特性去做的事并不止于 特性测试。细心一点，你会发现一些元素独一无二的特性可以被巧妙利用来做一些工作。 HTML转义创建 Option 实例，传入要被转义的字符串。因为 Option 构造函数第一个参数为 text，所以任你传入任何 html 代码都会被转义为 textNode。 new Option('&lt;div&gt;&lt;/div&gt;').innerHTML // \"&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;\" 同理，给 div 的 innerText 赋值，再通过 innerHTML 取，也可以做到，只是看起来不如一行代码来的巧妙。 var div = document.createElement('div');div.innerText = '&lt;a&gt;&lt;/a&gt;';console.log(div.innerHTML) // \"&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;\" 解析URLa 标签天生支持这些 URL 属性，是不是像极了 NodeJS 中 URL 对象。 var a = document.createElement('a');a.href = 'http://test.com:3000/a/b?k=1#dd';console.log(a.protocol); // \"http:\"console.log(a.host); // \"test.com\"console.log(a.hostname) // \"test.com\"console.log(a.port) // 3000console.log(a.pathname) // \"/a/b\"console.log(a.search) // \"?k=1\"console.log(a.hash) // \"#dd\" 获取一串文字在浏览器中所占的宽度想知道宽度还不简单，扔到浏览器中跑一圈看看。 var tester = document.createElement('div');tester.style.display = 'inline-block';tester.innerHTML = '博客：imys.net';document.body.appendChild(tester);console.log(tester.offsetWidth) display 属性一定要设置为 inline-block。因为 div:display 默认为 block，块级元素宽度默认等于父级元素宽度，这样获取到的宽度就不是字符的宽度了。 当你想用 js 去截断一段长文字时，可以使用这个例子。 判断canvas是否为空两个等宽等高内容相同的 canvas 所生成的 dataURL 是相同的，这样最终把对象的比较转换为字符串的比较。 function isCanvasBlank(canvas) &#123; var blank = document.createElement('canvas'); blank.width = canvas.width; blank.height = canvas.height; return canvas.toDataURL() === blank.toDataURL();&#125; 获取Computed styles这里的 Computed styles 不是指 getComputedStyle(element) 函数结果，而是像浏览器 Dev Tools 中 Styles 面板右侧的计算样式。是要获取最终被样式表影响的 css 属性，不包括标签默认属性和 user agent stylesheet。 function filterInheritedStyles(el)&#123; var tester = document.createElement(el.tagName); document.body.appendChild(tester); // 元素必须插入到文档中才能计算出默认样式 var defaultStyle = window.getComputedStyle(tester, null); var currentStyle = window.getComputedStyle(el, null); var ret = &#123;&#125;; for(var k in currentStyle) &#123; if(currentStyle.getPropertyValue(k) !== defaultStyle.getPropertyValue(k)) &#123; ret[k] = currentStyle.getPropertyValue(k); &#125; &#125; document.body.removeChild(tester); return ret;&#125; 创建一个标签相同的 Element 添加到文档中产生默认样式，与当前元素样式逐个比较，返回不一致的样式属性。 不过这个函数还不是最终版的。当一个元素被插入到文档中时，由于没有添加 id 、 class 、style 属性，也就不会受 id 选择器、类选择器、行内样式影响，但显然会受标签选择器影响。 所以如果能在返回值基础上对标签选择器属性进行过滤，才是最终结果。但目前通过 document.styleSheets 只限于获取内联样式表中规则，对于外部样式表中的规则检索还没有什么好的办法。 暂时只知道这么多。针对前端复杂的客户环境，单就 特性测试 而言已经可以帮我们解决很多问题了。","tags":[{"name":"html","slug":"html","permalink":"http://imys.net/tags/html/"},{"name":"技巧","slug":"技巧","permalink":"http://imys.net/tags/技巧/"},{"name":"element","slug":"element","permalink":"http://imys.net/tags/element/"}]},{"title":"获取移动设备旋转方向的几个方案","date":"2016-06-22T01:02:03.000Z","path":"20160622/screen-rotation-case.html","text":"某些偏门的 API 真是没有需求一辈子都不知道啊。 分享一下最近对于获取移动设备旋转方向的探索。 deviceorientationwindow.addEventListener('deviceorientation', function(e)&#123; console.log('absolute: ' + e.absolute) console.log('alpha: ' + e.alpha) console.log('beta: ' + e.beta) console.log('gamma: ' + e.gamma)&#125;); 之前在 segmentfault 回答过相关问题，当时是从 MDN 翻出了这个事件。 原贴：h5 页面如何获取手机陀螺仪的参数 该事件在移动端兼容较好：Android Webview 4.3+、Chrome for Android 5.0、iOS 8.4+，据我测试微信也是支持的。没有在低端机上测试过，可能该事件会依赖设备传感器，可以加个 &#39;ondeviceorientation&#39; in window 判断一下。 该事件触发频率高，适合对设备旋转精度要求较高的场景或是 3d 场景等，比如上面问题中的平衡球。 orientationchange 当设备的方向改变时，触发该事件。 window.addEventListener(\"orientationchange\", function() &#123; console.log('angle: ' + screen.orientation.angle);&#125;); 该事件是基于 2d 平面角度触发，输出仅有 0、90、270 3个数值，可以用来知晓当前设备的手持方向。至于为什么没有 360 这个角度，可能跟设备有关。我的手机怎么转都到不了 360 度，也就是竖屏时无法翻转。 触发这个事件需要设备开启屏幕旋转，或者叫屏幕锁定，不同的设备叫法不一样。 兼容性是个大问题，目前只发现手机上的 Chrome 可以使用，微信、iOS、以及一些双核国产浏览器都不兼容。 screen.orientation通过上个事件让我发现了screen.orientation，在控制台输出后，发现它也有事件支持。 console.log(screen.orientation) // &#123;angle: 0, type: \"landscape-primary\", onchange: null&#125;screen.orientation.onchange = function()&#123; console.log('angle: ' + screen.orientation.angle);&#125; 通过对该对象输出，发现也可以使用 screen.orientation.type 判断设备方向。 landscape-primary | landscape-secondary：横屏； portrait-primary | portrait-secondary: 竖屏； primary 表示向上或向右，secondary 表示向左或向下。 之后测试该事件，手机 Chrome 和国产双核浏览器通过，生产环境下使用还不够理想。 window.onresize完全是灵机一动想到的，设备旋转会使屏幕宽高置换，自然就会触发 resize 事件。 window.onresize = function()&#123; console.log('innerWidth: ' + this.innerWidth + ' innerHeight: ' + this.innerHeight);&#125; 通过屏幕宽高比较来判断横屏还是竖屏，设备兼容度毋容置疑。 Media Queries最后就是 css3 媒体查询了。 @media screen and (orientation: portrait)&#123; /* 横屏 */&#125;@media screen and (orientation: landscape)&#123; /* 竖屏 */&#125; 如果仅仅是为了针对屏幕方向添加样式的话，使用媒体查询是最佳方案了。 移动端使用也没有兼容问题，媒体查询从 IE9 就开始支持了。 测试Demo","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"mobile","slug":"mobile","permalink":"http://imys.net/tags/mobile/"}]},{"title":"javascript高阶函数介绍","date":"2016-05-30T15:02:08.000Z","path":"20160530/javascript-advanced-functions.html","text":"javascript 语言的特色之一便是函数即对象，因此便满足了高级函数的条件。 高阶函数在《javascript设计模式和开发实践》中是这样定义的。 函数可以作为参数被传递； 函数可以作为返回值输出。 实际上我们日常开发中会经常用到高阶函数。 接下来通过几个经典的应用案例，带你认知高阶函数。 回调函数提起回调，经典的应用莫过于 Ajax 异步请求。 以 jQuery 为例。 var getData = function(url, callback) &#123; $.get(url, function(data)&#123; callback(data); &#125;);&#125; 由于网络请求时间的不固定性，我们不能确定请求完成的具体时间，那么解决的办法就是传递一个处理函数作为参数到请求数据的方法中，请求完成后执行回调函数。 AOPAOP（面向切面编程）是著名的Java Spring框架中的核心概念之一。通过此编程模式可以在保持主逻辑代码不变的前提下，进行额外的功能拓展。 在 Java 中使用 AOP 往往要通过一些高级特性来实现，而 javascript 就简单多了。 比如测试一个函数的执行效率。 var service = function()&#123; console.log('功能逻辑...');&#125;var test = (function()&#123; var time_start; return &#123; before: function()&#123; time_start = (+new Date()); console.log('计时开始...'); &#125;, after: function()&#123; var end = (+new Date()) - time_start; console.log('计时结束，用时：' + end); &#125; &#125;&#125;)();var aop = function(fn, proxy)&#123; proxy.before &amp;&amp; proxy.before(); fn(); proxy.after &amp;&amp; proxy.after();&#125;aop(service, test);// 计时开始...// 功能逻辑...// 计时结束：1 柯里化 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 这概念着实让我琢磨了半天，转换成代码大概是这样的。 fn(1, 2, 3, 4) -&gt; fn(1)(2)(3)(4)() 假设这个函数是用于求和，那么就是把本来接收多个参数一次性求和的函数改成了接收单一参数逐个求和的函数。这样是不是容易理解了。 来实现一个柯里化求和函数。 var currying = function(fn)&#123; var args = []; return function()&#123; if(!!arguments.length) &#123; [].push.apply(args, arguments); return arguments.callee; &#125; else &#123; return fn.apply(this, args); &#125; &#125;&#125;var sum = (function(num)&#123; var ret = 0; return function()&#123; for(var i = 0, len = arguments.length; i &lt; len; i++) &#123; ret += arguments[i]; &#125; return ret; &#125;&#125;)();var newSum = currying(sum);newSum(1)(2)(3)(4)() // 10 看起来挺巧妙，但是这种案例明摆着就像不从实际出发的面试题。那再看下一个例子。 var find = function(arr, el)&#123; return arr.indexOf(el) !== -1;&#125; 一个简单的函数用于查询数组中是否某个值，每次使用都需要这样调用。 find(arr, 1);find(arr, 2); 既然 arr 是个固定参数，那么我们可以先保存一个接收过 arr 的函数，再用这个函数去处理变化的参数。 var newFind = currying(find)(arr);newFind(1);newFind(2); 反柯里化与柯里化相对应。 柯里化是为了缩小适用范围，创建一个针对性更强的函数； 反柯里化则是扩大适用范围，创建一个应用范围更广的函数。 对应的代码转换就变成这样。 fn(1)(2)(3)(4) -&gt; fn(1, 2, 3, 4) 实例 Array.forEach = function()&#123; var fn = [].pop.call(arguments); var arr = arguments.length &gt; 1 ? arguments : arguments[0]; return [].forEach.call(arr, fn);&#125;Array.forEach(1, 2, 3, function(i)&#123; console.log(i); // 1 2 3&#125;);Array.forEach('123', function(i)&#123; console.log(i); // 1 2 3&#125;);Array.forEach(&#123; '0': 1, '1': 2, '2': 3, 'length': 3&#125;, function(i)&#123; console.log(i); // 1 2 3&#125;); 类数组借用 Array 原型函数，是很常见的应用了。这个例子应用 call 函数提取出一个新的函数，可以接收更多的参数和类型，适用性更广。 函数节流函数节流也不算很厉害的技巧了，平常写代码严谨的人应该都有此类应用的经历。 比如页面滚动加载数据的场景。 当页面滚动到底部时，会触发 Ajax 去请求数据；当页面滚动频繁时，就可能出现上个请求还未结束又开始了一个新的请求。这个时候就需要用函数节流了。 var getData = (function()&#123; var onAjax = false; // 是否开始 ajax return function(callback)&#123; if(!onAjax) &#123; onAjax = true; $.get('/xxx', function(data)&#123; callback(data); onAjax = false; &#125;); &#125; &#125;&#125;)();$(window).scroll(function()&#123; if(滚动到底部) &#123; getData(render); &#125;&#125;); 分时函数与函数节流一样，分时函数也是用来解决函数频繁执行带来的性能问题。不同的是，函数节流场景为被动调用，分时函数为主动调用。 就算一个列表展示页面没有使用分页组件，也会像上个例子那样触发式分组渲染。而如果真的遇到需要一次性把所有数据渲染到列表时，大量的 DOM 创建会对浏览器造成极大开销，或卡顿、或假死等。 该处理是否必须同步完成？ 数据是否必须按顺序完成？ 如果以上两个问题都为“否”的话，为何不尝试分割这个处理过程。 // arr: 源数据// process: 处理函数// count: 每次抽取个数var chunk = function(arr, process, count)&#123; setTimeout(function()&#123; for(var i = 0; i &lt; Math.min(count, arr.length); i++) &#123; process(arr.shift()); &#125; if(arr.length &gt; 0) &#123; setTimeout(arguments.callee, 100); &#125; &#125;, 100);&#125; 创建一个队列，使用定时器取出下一批要处理的项目进行处理，接着在设置另一个定时器。 一旦某个函数需要花 50ms 以上的时间完成，那么最好看看能否将任务分割为一系列可以使用定时器的小任务。 惰性加载当你逛网店发现了心怡的商品时，是立刻收藏或加购物车，还是等到买的时候再搜索相关商品一个一个的找到它？ 浏览器特征检测是前端开发中必不可少的，比如返回顶部，我们需要区分火狐和其他浏览器来决定 scrollTop 应当设置给谁。 // 新手var gotop = function()&#123; if(/firefox/i.test(navigator.userAgent)) &#123; document.documentElement.scrollTop = 0; &#125; else &#123; document.body.scrollTop = 0; &#125;&#125;// 老司机var gotop = (function()&#123; var isFF = /firefox/i.test(navigator.userAgent); var docEl = document[ isFF ? 'documentElement' : 'body' ]; return function()&#123; docEl.scrollTop = 0; &#125;&#125;)(); 浏览器的特征是保持不变的，既然如此为什么不一开始就保存下来呢。 与此同理，日常编程中要注意缓存那些经常使用、改变较少或不做改变的内容。 参考 《JavaScript设计模式与开发实践》 《JavaScript高级程序设计》 第三版 JS函数式编程指南 - 柯里化 《编写高质量代码：改善JavaScript程序的188个建议》","tags":[{"name":"Function","slug":"Function","permalink":"http://imys.net/tags/Function/"},{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"Hexo添加站内搜索功能初步完成","date":"2016-05-11T08:08:50.000Z","path":"20160511/hexo-search.html","text":"不止一次有同学在 Issues、邮件等渠道中向我反馈增加站内搜索功能。本来准备什么时候搞个 2.0 版的主题再加上这些新功能，可一直没什么太好的想法，反正也是折腾，就把搜索功能做了一下。 搜索方案针对无数据库的静态博客搜索方案一般有两种： 第三方搜索服务； 序列化站点内容作为数据源，然后自己写查询方法。 第三方搜索服务基于搜索引擎的包括 Google 和百度提供的站内搜索，比如 Hexo 文档中的辅助函数 search-form 就提供了一个 Google 搜索框。搜索结果取决于该搜索引擎对你站点的收录情况。 抛开其他原因来讲，没有颜值的搜索服务我是不会考虑的。 接着我实验了一下在 Hexo 中有用户基础的 Swiftype 和 Hexo 官网使用的 Algolia。 SwiftypeSwiftype 安装很简单，关于其在 Hexo 中使用的文章介绍也很多，我只说下使用体验。 配合我自定义的搜索框样式，外观展现还算过关。 可以对色调进行修改，由于是在单页面展示搜索结果，就算不提供外观修改也可以自己重写 css ，类似多说。 搜索结果的展示可以自定义，包括内容布局、字段排列、分页等。 搜索结果容器可完全自定义，可设置单页或新页面显示搜索结果，对外观的控制力更强。 可以设置字段权重，比如优先展示文章标题的匹配结果。 可以单独为某个关键字搜索结果进行管理，比如排序、置顶、删除等等，话说某度推广不就是这样吗。 可以设置抓取规则，比如只抓取文章页。 默认的字段匹配不满意，下图是对hexo的搜索结果。Swiftype 的body字段默认抓取整个页面，我每个页面的左侧 footer 都有hexo这个单词，在我设置了只抓取文章页后，博客一共 46 篇文章也就匹配了 46 个结果。我期望它只对文章内容检索，这样更精准。 如果能自定义抓取字段，指定抓取内容当然是极好的。Swiftype 文档中也提供了这方面内容，Crawler。 大概看了一下，感觉 Content Inclusion/Exclusion 和 Meta Tags 方式应该能满足需求。我也尝试了一下，发现没效果，不知道是不是要重新抓取才生效。 设置重新抓取后等了 1 个小时还没什么效果，我只好先进行下一步了。 AlgoliaAlgolia 我只注册了账户，然后就没有然后了。。。因为我准备使用方案2了。 从 Algolia 管理界面和文档上来看不会比 Swiftype 差，可留作备选。 自定义搜索没有数据库的前提下实现查询，也可以使用数据文件做数据源。Hexo 中也有这方面的先驱者，在 Hexo-Plugins 页可以找到生成数据文件的两个插件，hexo-generator-json-content 和 hexo-generator-search。 hexo-generator-json-content 生成的数据文件为json格式。 meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content //-&gt; final HTML content&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text ;) keywords: null //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;] hexo-generator-search 生成的数据文件为xml格式。 &lt;search&gt; &lt;entry&gt; &lt;title&gt;Post title&lt;/title&gt; &lt;url&gt;http://yourposturl.html&lt;/url&gt; &lt;content type=\"html\"&gt;helloworldhelloworldhelloworldhelloworldhelloworldhelloworld&lt;/content&gt; &lt;/entry&gt; &lt;entry&gt; &lt;title&gt;Post title&lt;/title&gt; &lt;url&gt;http://yourposturl.html&lt;/url&gt; &lt;content type=\"html\"&gt;helloworldhelloworldhelloworldhelloworldhelloworldhelloworld&lt;/content&gt; &lt;/entry&gt;&lt;/search&gt; 对于 js 语言来说还是解析 json 更方便，如果需要用xml做数据文件我完全可以使用已有的atom.xml。 hexo-generator-json-content 生成的json数据内容挺全的，不过并不是我都需要的。可以通过添加站点配置设置你需要生成的字段。 meta是站点信息，pages是除文章页以外的页面信息，这都是我不需要的，我只要求搜索文章页。 此外，文章页的字段也可以根据需求减少，以减小数据文件大小。下图可以直观看出每个字段表示的内容。 slug、comments、link、keywords、categories都是无内容或不需要的字段； date和updated、path和permalink留其一即可； excerpt可以不要，因为我们要检索文章全文； raw是markdown元数据，content是包含html标签的文章内容，处理起来最方便的是text纯文本。 最后的配置如下，需要放到hexo/_config.yml中。 jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 接着就是实现查询方法并把结果渲染到页面。 // xhr加载数据function loadData(callback) &#123; // 略...&#125;// 匹配文章内容返回结果function matcher(post, regExp) &#123; // 匹配优先级：title &gt; tags &gt; text return regExp.test(post.title) || post.tags.some(function(tag) &#123; return regExp.test(tag.name); &#125;) || regExp.test(post.text);&#125;// 渲染到页面function render(data) &#123; // 略...&#125;// 查询function search(key) &#123; // 关键字 =&gt; 正则，空格隔开的看作多个关键字 // a b c =&gt; /a|b|c/gmi var regExp = new RegExp(key.replace(/[ ]/g, '|'), 'gmi'); loadData(function(data) &#123; var result = data.filter(function(post) &#123; return matcher(post, regExp); &#125;); render(result); &#125;);&#125; 正则加上filter、some两个数组过滤函数，就这么简单。也没想做太复杂，否则匹配结果高亮、匹配片段截取又够折腾半天。 完成后就是现在博客的搜索了，PC 端浮动面板显示，Mobile 端全屏显示。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"}]},{"title":"Vue中的数据交互","date":"2016-05-03T09:39:44.000Z","path":"20160503/vue-data-interaction.html","text":"在 Vue 中通常以一个 Vue 实例来表示一个应用，一个应用由若干个组件拼装而成。没错，就像“装机”一样。当你把主板、CPU、显卡、内存、散热器、SSD、电源等摆放到机箱的各个位置后，很明显产生了一个明确的需求：我怎么让这些东西协同工作？回到 Vue 中，处理不同组件之间的数据或状态是一件经常遇到的事。 好在 Vue的文档 足够详细。关于组件交互的部分，如果没有实际需求，我表示难以明白props以及自定义事件等使用场景是什么。 Propsprops是定义在子组件中的属性，用来定义期望从父组件传下来的数据。 从实际场景着手，写一个简单的需求。 &lt;!-- 子组件模板 --&gt;&lt;template&gt; &lt;p&gt;&#123;&#123;helloWorld&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;template&gt; &lt;input type=\"text\" v-model=\"text\"&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt; 当父组件中输入内容时显示到子组件中。 这时，我需要在子组件中声明一个 props 属性来接收父组件中输入的内容。 // 子组件module.exports = &#123; props: &#123; helloWorld: String &#125;&#125;;// 父组件module.exports = &#123; components: &#123; child: require('child') &#125;, data: function()&#123; return &#123; text: '' &#125; &#125;&#125;; 还需要告诉子组件，它的 props 对应父组件中的哪个数据。 &lt;!-- 在子组件上标记 --&gt;&lt;child :hello-world=\"text\"&gt;&lt;/child&gt; camelCase 格式属性用作 HTML 特性时需要转换成 kebab-case 格式。 当前需求轻松的解决了！ 有没有发现 props 好像是单向的，父 -&gt; 子？ 不，并不是。只是默认是单向的。可以通过添加额外的修饰符来显示强制双向或单词绑定。 &lt;!-- 双向绑定 --&gt;&lt;child :hello-world.sync=\"text\"&gt;&lt;/child&gt;&lt;!-- 单次绑定 --&gt;&lt;child :hello-world.once=\"text\"&gt;&lt;/child&gt; 而正像 Vue 文档中所说的，默认单向绑定是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 举个例子，如果当前子组件设置为双向绑定，另有其他的子组件依赖父组件的helloWorld属性。这种关系下如果子组件修改了数据，势必引起其他子组件的状态改变。某些场景下我们并不希望发生这种情况。 自定义事件使用自定义事件也可以实现父子组件之间的通信，通过事件触发的形式来传递数据。 使用$on()监听事件； 使用$emit()在它上面触发事件； 使用$dispatch()派发事件，事件沿着父链冒泡； 使用$broadcast()广播事件，事件向下传导给所有的后代。 现在变更需求，把输入框拿出来作为子组件B。 &lt;!-- 子组件B模板 --&gt;&lt;template&gt; &lt;input type=\"text\" &gt;&lt;/template&gt;&lt;!-- 父组件模板 --&gt;&lt;template&gt; &lt;child-b&gt;&lt;/child-b&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt; 当子组件B内容变化时，我应当通知父组件：头儿，我的工作完成了。 &lt;template&gt; &lt;input type=\"text\" v-model=\"text\" @change=\"onInput\"&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: function () &#123; return &#123; text: '' &#125; &#125;, methods: &#123; onInput: function () &#123; if(this.text.trim()) &#123; this.$dispatch('child-next', this.text); &#125; &#125; &#125;&#125;;&lt;/script&gt; 父组件收到通知后，广播给其他需要的子组件：B已经完成XXX了，剩下的东西交给你了。 module.exports = &#123; components: &#123; child: require('child'), 'child-b': require('childB') &#125;, events: &#123; 'child-next': function (text) &#123; this.$broadcast('child-finish', text); &#125; &#125;&#125;; 或者为了能从父组件中直观的看出事件来源，可以使用显示声明绑定事件。 &lt;template&gt; &lt;child-b @child-next=\"handle\"&gt;&lt;/child-b&gt; &lt;child&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; components: &#123; child: require('child'), 'child-b': require('childB') &#125;, methods: &#123; handle: function (text) &#123; this.$broadcast('child-finish', text); &#125; &#125;&#125;;&lt;/script&gt; 接收广播的子组件，需要添加对应的处理事件。 &lt;template&gt; &lt;p&gt;&#123;&#123;helloWorld&#125;&#125;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;module.exports = &#123; data: function () &#123; return &#123; helloWorld: '' &#125; &#125;, events: &#123; 'child-finish': function (text) &#123; this.helloWorld = text; &#125; &#125;&#125;;&lt;/script&gt; 与 props 方式相比，自定义事件的方式各个组件的数据独立，不会被父或子组件轻易修改。因为我们能控制在何时进行事件派发和广播。 当然这两种方式并不冲突，可以结合使用来创造最佳实践。 Vuex最后就是使用大杀器 Vuex 了。 不管是props还是自定义事件，如果数据要由子组件到另一个子组件中，都要进行父组件的中转。随着项目的逐步增大，数据流也会变得复杂，难以管理和发现问题。 而 Vuex 就是独立的一个数据管理层。你需要把组件的本地状态和应用状态区分开来，把应用状态交由 Vuex 来管理，方便每一个组件去交换数据更新状态。 这是一个简单的例子","tags":[{"name":"vue","slug":"vue","permalink":"http://imys.net/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://imys.net/tags/vuex/"}]},{"title":"一个HTML元素可以做什么？","date":"2016-04-13T08:37:53.000Z","path":"20160413/one-element-can-do-much.html","text":"自 CSS3 问世以来，在广大开发者的智慧下诞生了很多创造性的设计，如：18个你可能不相信是用CSS制作出来的东西。个人平时也喜欢收藏这些有趣的东西，其中一些设计对单个 HTML 元素的极限利用，很值得我们去学习。 以下就来说一说这些神奇的黑科技。 伪元素伪元素是比较常见的单元素利用了，:before与:after基本上支持普通元素的所有 CSS 属性，它使 1 个元素可以当作 3 个元素来使用。 比如制作一个单元素的菜单图标，三条线。 .icon-menu &#123; position: relative;&#125;.icon-menu,.icon-menu:before,.icon-menu:after &#123; width: 1em; height: .25em; background: #666;&#125;.icon-menu:before,.icon-menu:after &#123; content: ''; position: absolute; left: 0;&#125;.icon-menu:before &#123; top: .3125em;&#125;.icon-menu:after &#123; top: .625em;&#125; 在辅以圆角、CSS三角等，一些看起来复杂的图标也不是不能实现。Github 早已有 css 图标的项目了：Cikonss。 实际场景中的应用不限于此，如：下拉菜单上的三角箭头、时间线上的圆点标记（在我的博客归档页就是此种）等。当你需要添加一些无内容的修饰性元素时，你就该想到使用伪元素。但也不是说有内容的用伪元素无法实现，一些静态的展示内容也可以用，可以利用伪元素content属性。 比如一个带统计数量的badge，对应的 html 可以这样写。 &lt;span data-count=\"10\" class=\"badge\"&gt;消息&lt;/span&gt; 在 css 中利用伪元素展示自定义属性。 .badge:after &#123; content: attr(data-count); /* ... */&#125; 我的博客 PC 端文章页右侧的分享所用的 tips 就是利用伪元素纯 css 实现的。 borderborder实现 css 图形的案例已经屡见不鲜了，实际应用中常用的还是三角形。 既然提到了border，也应该顺带提下outline。两者都可以肆意的实现各种长短粗细的线条，一些特殊的场景中一条粗边框就可当作一个矩形来利用。还拿菜单图标来说，设置上下两个边框样式，outline 在画上一条，可以通过outline-offset来调整间距，是不是也能凑出一个图标呢。 除了使用border绘制多边形外，其实扇形、弧线也是可以很容易实现的。 /* 扇形 */.sector &#123; width: 0; height: 0; border: 30px solid #000; border-top-color: transparent; border-bottom-color: transparent; border-radius: 50%;&#125;/* 弧线 */.arc &#123; width: 40px; height: 40px; border: 1px solid #000; border-top-color: transparent; border-bottom-color: transparent; border-radius: 50%;&#125; 具体是什么效果，自测吧。 扇形、弧线可以轻易的制作一个 loading 效果：css实现的各种loading效果。 box-shadowbox-shadow可以设置元素阴影效果，且可以设置多组值。但是我万万没有想到它居然强大如斯：1个元素实现的像素画。 先看下box-shadow的文档介绍压压惊。 box-shadow: [inset] offset-x offset-y [blur] [spread] [color]; 值 说明 inset 可选，默认阴影在边框外。使用inset后，阴影在边框内（即使是透明边框），背景之上内容之下。 offset-x/offset-y 必需，用来设置阴影偏移量。offset-x设置水平偏移量，如果是负值则阴影位于元素左边。offset-y设置垂直偏移量，如果是负值则阴影位于元素上面。如果两者都是 0，那么阴影位于元素后面。这时如果设置了blur或spread则有模糊效果。 blur 可选，模糊距离。值越大，糊糊面积越大，阴影就越大越淡。 不能为负值。默认为 0，此时阴影边缘锐利。 spread 可选，阴影的大小。取正值时，阴影扩大；取负值时，阴影收缩。默认为0，此时阴影与元素同样大。 color 可选，阴影的颜色。 平常使用中一般会设置 4 个值来实现阴影效果，即offset-x、offset-y、blur、color。从属性介绍中看当blur省略后，默认值为 0，边缘锋利，也就是小方块的效果。而通过设置每一组offset-x、offset-y的偏移值，加上不同的颜色设置，的确是实现像素画的绝妙之想。 当前博客的404页面就是用box-shadow堆叠出来的。 相关资源分享： singlediv css图形 26个字母 原来这个世界还有另外一种 css：别人手中的 css。","tags":[{"name":"html","slug":"html","permalink":"http://imys.net/tags/html/"},{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"}]},{"title":"CSS实用Tips","date":"2016-04-06T09:42:48.000Z","path":"20160406/css-tips.html","text":"作为自己做前端开发以来的CSS爬坑总结，内容偏向PC端，不定期补充。只作提示，不深谈。 盒子模型1、区分content-box和border-box的尺寸计算。 2、行级元素无宽高，但可设内外边距。 3、外边距margin可设负值，内边距padding不可以。 4、当内外边距值为百分比时是相对于元素宽度计算的。 5、border是个好玩的东西，关键字：css三角形。 定位与布局1、添加了position: absolute与float样式后，元素会隐式改变display属性为inline-block，可以设置宽高属性，不需要再显示设置display。 2、清除浮动，一般有clear: both/left/right和overflow: hidden。首选clear，如果目标区块存在溢出元素时，会被overflow: hidden截断。 3、绝对定位的元素，在top、right、bottom、left属性未设置时，默认为auto，在文档流中紧跟前一个元素。这个特性通常可以实现一些神奇的效果。 4、尽量为每一个定位元素合理分配z-index，特别是relative元素。按级别一般为：主体内容 &lt; 下拉列表、日历等与主体紧密联系的内容 &lt; 浮动的头部或左右导航、工具栏等 &lt; 遮罩、模态窗口等。遵循这个规则能少踩很多坑。 5、绝对定位的元素可以溢出添加了overflow: hidden的父容器且不被截断；绝对定位的起始点是参照离其最近的祖先定位元素，一直到body。 6、隐藏元素一般用display: none、visibility: hidden，使用CSS3过渡和动画时首选visibility。因为display只有两个状态改变none -&gt; block/inline-block/...，没有值域的变化（我是这么理解的），visibility在底层实现中是有一个 0-1 的变化。 7、当IE&lt;=7时，遇到定位布局问题，你可能需要了解haslayout与层叠上下文。 8、在移动端开发中，使用Flexbox新旧语法混合是很好用的布局解决方案。 选择器1、一些简单的交互效果就不需要用js去实现了，灵活使用选择器就可以搞定。如：鼠标悬浮于一个元素时显示某个子元素或兄弟元素、输入框具有焦点时显示输入提示、CSS模拟单复选框等。 2、jquery中有的选择器，基本上也能在CSS中使用或找到替代方案。 3、链接的伪类样式要按照link、visited、hover、active顺序设置，移动端用active代替hover。 4、除了首元素、末元素外，还有首行选择器:first-line和首字符选择器:first-letter。 5、使用子元素伪类选择器:nth-child(n)可以按照你的规则选取任意组合的子元素。 6、伪元素选择器:before/:after可以把一个元素当作三个元素使用，需注意某些元素不支持该选择器。其属性content为必设值，可以是字符串或使用attr()插入元素属性值、使用url()插入图像等。 排版与修饰1、文本处理：大小写转换text-transform、文字截断text-overflow、改变文本流方向direction、书写方向writing-mode、换行处理white-space等。 2、当font-weight设为数值时，需要对应的字体有该数值字重支持，否则无效。bold等价于700数值。 3、垂直对齐vertical-align是个资深奇葩，各个浏览器解析均有差异。除了一些固有属性值外，还可以设数值、百分比。 4、你想设置2个边框吗？使用outline吧。 5、浏览器字体最小基准是12px。 6、设计图中的一些字体效果，可以尝试用text-shadow实现，减少图片应用。 7、使用CSS3时遵循渐进增强原则，对于不支持的浏览器保证布局无错乱、功能正常使用。","tags":[{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"}]},{"title":"使用HTML5 history API增强移动端用户体验","date":"2016-03-16T06:42:51.000Z","path":"20160316/use-history-pushState.html","text":"起因最近做的一个图片浏览功能，请自行脑补手机图库、微博查看图片等场景。功能做好之后，马上有同学反应：进入图片浏览层时，如果用户触摸手机后退按钮，整个页面都会返回，能否在触摸返回时只关闭浏览层？ 一般移动端会对 WebView 做一些默认的设置，比如 Hook 用户触摸后退按钮，调用 WebView 后退方法。既然如此，就可以利用这一点，通过操纵浏览记录使用户触摸后退关闭浏览层。 history想要操纵浏览记录，就不得不提history对象了。通过常用的back()、forward()、go()方法就可以自由的控制浏览器跳转到任意一个历史记录。而在 HTML5 中，history 又添加一些新的成员，允许你对浏览记录进行添加和修改却不会刷新页面，这就是解决问题的关键了。 history.pushState(stateObj, title, url) 用于创建新历史记录； history.replaceState(stateObj, title, url) 用于修改当前历史记录； history.state 读取当前状态，创建历史记录时会添加状态对象； window.onpopstate 是一个事件，当历史记录被修改时会触发。 简单实现&lt;div id=\"container\"&gt;&lt;/div&gt; 就把这个 div 看作一个图片浏览层吧，样式脑补。 function Demo(id) &#123; this.el = document.getElementById(id);&#125;Demo.prototype = &#123; constructor: Demo, show: function() &#123; // 处理显示的代码... this.el.classList.add('in'); &#125;, hide: function() &#123; // 处理隐藏的代码... this.el.classList.remove('in'); &#125;, useState: &#123; show: function() &#123; // 参数1是 Object 类型，可以被 history.state 读取 // 参数2是标题，在一些浏览器中会被忽略，象征性的传空就可以了 // 参数3是新记录的地址，会在末尾追加，如：http://test.com/demo history.pushState(&#123; page: 'demo' &#125;, '', '/demo'); // 调用真正的显示方法 this.show(); &#125;, hide: function() &#123; // 返回上一条历史记录 history.back(); &#125; &#125;, bindEvent: function() &#123; var _this = this, handelShow = this.show, handelHide = this.hide, imgs = document.getElementsByTagName('img'), // 假设图片浏览层上有一个 .back 后退按钮 back = document.getElementsByClassName('back')[0]; // 加个判断避免兼容性问题 if(history.pushState) &#123; // 如果可以使用 history API 就重新赋值 handelShow 和 handelHide handleShow = this.useState.show.bind(this); handleHide = this.useState.hide.bind(this); // history.state 变化时触发，假设初始 URL = http://test.com window.onpopstate = function(e) &#123; // 这里的 e.state 和 history.state 等价的 if(!e.state) &#123; // 无状态时隐藏 _this.hide(); console.log(document.location); // http://test.com &#125; else if(e.state.page === 'demo') &#123; // 如果是自己定义的状态就显示 _this.show(); console.log(document.location); // http://test.com/demo &#125; &#125;; &#125; // 给图片绑定事件 [].forEach.call(imgs, function(img)&#123; img.addEventListener('touchstart', function() &#123; handelShow(); &#125;); &#125;); // 图片浏览层上的后退事件 back.addEventListener('touchstart', function() &#123; handelHide(); &#125;); &#125;&#125;;// 调用new Demo('container'); 执行history.pushState()时不会触发window.onpopstate，只有前进forward()、后退back()时才会触发，所以在之后还需要调用显示的方法。对于不支持history.pushState的浏览器执行的还是原来的显示和隐藏方法，handleShow和handleHide在判断内才被重新赋值。通过在window.onpopstate判断history.state来执行不同的操作，当然你也可以判断location。 以上代码未经测试，只作思路展示，注释说明了一切。 应用场景在 SPA 场景中，history 早已大显神通。与history.state相似的还有location.hash，也有其对应的事件window.onhashchange，一般用于处理 IE 低版本的兼容。抛开本篇描述的功能需求，类似的场景也可以运用。比如左侧导航在原生APP都是可以通过触摸返回来关闭，在浏览器中也可以模拟这种操作体验。","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"用户体验","slug":"用户体验","permalink":"http://imys.net/tags/用户体验/"},{"name":"history","slug":"history","permalink":"http://imys.net/tags/history/"}]},{"title":"阿里云搭建Git服务，实现Hexo自动部署","date":"2016-03-03T08:33:19.000Z","path":"20160303/hexo-nginx-auto-deploy.html","text":"使用 gitcafe pages 更新博客只需要敲几条命令，如果因为博客搬到了阿里云，却没有原来操作方便，那便得不偿失了。所以就准备在服务器上建个 Git 远程仓库，用 Git Hooks 实现自动部署。 Git HooksGit Hooks 就是一些触发特定事件的脚本。比如 commit、push、merge 等等，也区分本地 Hooks 和服务端 Hooks。我这次使用的是post-receive。 当用户在本地仓库执行git-push命令时，服务器上远程仓库就会对应执行git-receive-pack命令，而git-receive-pack命令会调用pre-receive钩子。 这需要在服务器上建立一个 Git 远程仓库，和一个用于获取更新（git pull）的本地仓库。 远程仓库：最原始的版本库，所有的本地仓库就可以克隆这个仓库。就像你在 Github 创建一个项目，这就是一个远程仓库。本地仓库：这个就是平常的工作目录，容易理解。 总体的流程为： 本地执行git push； Git 服务器更新并 Hook； 执行pre-receive脚本，命令为：定位到服务器本地仓库目录，执行git pull。 我的 git 已经安装了，Ubuntu 安装很简单： sudo apt-get install git 创建 git 用户，用来运行 git 服务： sudo adduser git 用 git 用户运行貌似是约定俗成的事，像 github 一个仓库的 URL 为git@github.com:user/project.git，@ 符号前面的 git 就是运行 git 服务的用户名。 初始化远程仓库： 我的目录名为website，仓库名为blog，以此为例。 cd /website sudo git init --bare blog.git 远程仓库名以.git结尾。还需要给 git 用户设置该目录的权限： sudo chown -R git:git blog.git 出于安全考虑，禁用 shell 登录： vi /etc/passwd 找到这一行： git:x:1002:1002:,,,:/home/git:/bin/bash 修改为： git:x:1002:1002:,,,:/home/git:/usr/bin/git-shell 可以使用git-shell，通过ssh使用 git，但无法使用 shell 登录。 创建证书登录，把本地公钥添加到/home/git/.ssh/authorized_keys。不过默认的id_rsa公钥一般都被占用了，可以再建个其他名字，创建.ssh/config区分。 初始化服务器本地仓库： 我是在远程仓库旁边建立的。 cd /website git clone blog.git 因为是在同一台电脑上，所以克隆直接使用本地路径。这将会在website生成一个名为blog本地仓库。 ls -la 可以看到当前路径下有一个blog.git目录和一个blog目录。 考虑到 git-hooks 运行使用的是 git 用户，也对服务器本地仓库授权： chown -R git:git blog 设置 hook 执行脚本： vi blog.git/hooks/post-receive 输入以下内容： #!/bin/sh cd /website/blog git pull origin master 很好理解，就是定位到服务器本地仓库然后拉取更新。 保存后赋予可执行权限： chmod +x blog.git/hooks/post-receive 现在可以在本地（你的电脑上）进行测试了。 找一个目录，进行版本库克隆： git clone git@server:/website/blog.git server 是你的服务器域名或者IP。 因为仓库还没有内容，所以会显示：You appear to have cloned an empty repository. 你克隆了一个空仓库。 现在可以随便创建点东西，push 到远程仓库，然后到/website/blog目录下看看有没有变化。 我在操作的时候遇到一个错误：fatal: Not a git repository: ‘.’ 因为 hook 脚本执行了 cd 之后，继续执行 git 语句拉取的时候还是在 hooks 文件夹下，而不是 cd 的文件路径。 修改后的脚本如下： #!/bin/sh unset GIT_DIR #还原环境变量 cd /website/blog git pull origin master 现在已经实现本地到远程服务器的同步了，只差一个 Web 服务器了。 Nginx安装配置目前我的博客在 gitcafe 上，在 URL 后面随便加点后缀进入 404 页面，可以清楚的看到 nginx/1.8.0 的字样。以后还要玩负载均衡，服务器肯定就选它了。 sudo apt-get install nginx 看了很多文章，发现其中描述的 Nginx 的文件结构都不太一样，看来跟系统环境有关系。我的目录结构如下，环境是阿里云 Ubuntu 14.04 ： 所有的配置文件都在/etc/nginx下，并且每个虚拟主机已经安排在了/etc/nginx/sites-available下 启动程序文件在/usr/sbin/nginx 日志放在了/var/log/nginx中，分别是access.log和error.log 在/etc/init.d/下创建了启动脚本nginx 默认的虚拟主机的目录设置在/usr/share/nginx/html 启动 Nginx ： sudo /etc/init.d/nginx start 默认的服务器配置是 80 端口，如果你没有其他的 Web Server 在运行，打开服务器域名或 IP 应该可以看到Welcome to nginx! 现在定位到配置文件，修改配置： vi /etc/nginx/nginx.conf 找到server { ... }区域： server &#123; listen 80; #端口 server_name localhost yoursite.com; #域名或IP root /website/blog; #站点根目录 charset utf-8; #文件编码 index index.html index.htm; #首页 error_page 404 /404.html; #404页面 error_page 500 502 503 504 /50x.html; #服务端错误页面 #url访问匹配路径，可以添加多个 location / &#123; index index.html index.htm; root /website/blog; #这里可以是绝对路径或者相对路径，基于站点根目录 &#125;&#125; 可以用一条命令测试配置是否正确： nginx -t -c /etc/nginx/nginx.conf 重启 Nginx 服务器使配置生效： /etc/init.d/nginx restart 现在开始部署 Hexo。 Hexo 部署原来的 Hexo 使用的是 hexo-deployer-git 插件，会在 Hexo 下生成一个 .deploy_git 目录，从这个目录上传到 pages 分支。现在我觉得不需要这个插件了，可以直接在 public 目录下初始化 git 仓库然后上传。 cd hexo/public git init git add -A git commit -m &apos;add myBlog&apos; git remote add origin git@server:/website/blog.git git push origin master 这时候打开站点，就可以看到博客了。 我的域名还没有备案，之前注册的域名有备案号，需要迁到阿里云。好像审核期间需要关站，真是麻烦。 参考 廖雪峰-搭建Git服务器 使用 Git Hooks 实现自动项目部署 Nginx中文文档","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"http://imys.net/tags/Nginx/"},{"name":"Linux","slug":"Linux","permalink":"http://imys.net/tags/Linux/"},{"name":"部署","slug":"部署","permalink":"http://imys.net/tags/部署/"}]},{"title":"阿里云Linux-Ubuntu折腾记","date":"2016-02-20T08:25:34.000Z","path":"20160220/start-linux-on-aliyun.html","text":"观望阿里云很久了，终于在这个春节来了后，一咬牙、一狠心、一跺脚就买下了一台 ECS。不分昼夜的折腾了几天后，终于在几天前配置好了自己期望的使用环境。由于本人初次接触 Linux，配置期间三度初始化磁盘（等价于手机恢复出厂设置），可以说是一步一个坑的走下来的。现趁热打铁对最后一次正确的安装配置做一下总结，给后人乘凉吧。 选择配置作为开发者，选择 Linux 是毋庸置疑的。 CPU 单核2G，对于我目前来说绝对是够用了。我会用来做什么？当然是瞎折腾了！一台远程服务器就相当于你多了一台24小时不关机的电脑，可以挂点有趣的服务跑着，比如爬虫之类。或者当个代码仓库，用来项目演示。当然，博客也肯定会迁过去的。带宽 2G，不知道带宽提升是不是会影响远程桌面速度。对于 Linux 的诸多版本之间的优劣，我也不甚了解，就选了个耳濡目染较多的 Ubuntu，版本自然是选最新版的64位。Linux 自带 20G 系统盘，另外我又加了一块 100G 云盘，感觉现在还用不了这么大空间。 以上配置一年的价格是 1200+，我选择的地域是青岛，比国内其他地域相对便宜点。另外付款的时候填写推荐码可以优惠 10%，这是我的推荐码：rg2j5m。当然你使用我的推荐码付款后我将得到一定的返比代金卷，可以用来购买阿里云的产品。 目的本文最终将会配置完成这样一个 Linux 使用环境： GNOME 中文图形界面； Windows 远程桌面连接； Nodejs 安装。 更新软件源不管是从阿里云连接管理终端还是用的 Putty 等 SSH 连接工具，总之你现在应该已经打开一个黑窗口了。开始第一步。 sudo apt-get update apt-get是一个包管理工具，在 Ubuntu 环境下，会是你以后经常用到的命令之一，类似于 Nodejs 环境下的npm。apt-get 命令一般需要 root 权限执行，所以一般跟着sudo命令。某些情况下，如果你的一个命令运行失败，可以加上sudo命令再尝试下，也许就神奇的成功了。 Linux 系统基本上分两大类： RedHat系列：Redhat、Centos、Fedora等，使用 yum； Debian系列：Debian、Ubuntu等，使用 apt-get。 apt-get 常用命令： update 更新软件包列表 upgrade 升级软件包 install pkg 安装软件包 remove 移除软件包 参考：apt-get的更多使用 在查找 Linux 相关资料时，尽量带上系统环境与版本，不同版本环境下出现问题的解决办法不一定适用。 GNOME 安装安装 x-window 的基础： sudo apt-get install x-window-system-core 安装 GNOME 登录管理器： sudo apt-get install gdm 安装 Ubuntu 的桌面： sudo apt-get install ubuntu-desktop 安装 GNOME 基础软件： sudo apt-get install GNOME-core OK！现在从阿里云连接管理终端登录的话，就可以看到 GNOME 漂亮的登录界面。如果还是黑屏的话，执行startX命令。 startX 即为启动 x-window 服务，适用于任何图形界面的启用。 在 Ubuntu 环境下当然不止 GNOME 一种图形界面，常见的还有 KDE、XFCE 等，从第2个步骤开始对应命令如下： sudo apt-get install kdm 或 xdmsudo apt-get install Kubunut-desktop 或 Xubuntu-desktop 我没有使用经验，不知道孰优孰劣，有兴趣，可自行尝试。不过这三种桌面我倒是都安装过，之所以最后选择 GNOME 完全是撞上了，因为我三度初始化磁盘。对，是巧合！从界面美观上看，我更倾向于最后的 GNOME。 设置中文环境这个坑我爬了很久！ 如果你的人品好，请使用最简单的界面设置方式来切换语言环境。 System Settings -&gt; Language Support 进来会有一个弹出框自动安装语言更新，直接关掉 Install/Remove Languages… -&gt; Chinese Simplified 勾选 -&gt; Apply Changes 从上面列表里把汉语拉到第一位，如果可以的话（反正我是怎么都拉不上去） 选项卡 Text -&gt; 列表里选择汉语 -&gt; Apply System-Wide… 注销后登录就是汉语了 而我是使用命令的方式强行设置的。上面的步骤最好先尝试下，我也不确定直接使用命令形式设置能否成功。 安装中文的支持 sudo apt-get install language-selector language-env language-pack-zhv 使安装生效，配置区域，看到zh_CN.UTF-8... up-to-date就表示成功了 dpkg-reconfigure locales 将本地默认语言改为中文 LC_ALL=zh_CN.UTF-8 配置系统环境 sudo vi /var/lib/locales/supported.d/zh 加入以下配置参数： zh_CN.GB18030 GB18030zh_CN.GBK GBKzh_CN.GB2312 GB2312zh_CN.GB18031 GB18031zh_HK.BIG5 BIG5zh_TW.BIG5 BIG5 生成locale（保存在/usr/lib/locale/中）： sudo locale-gen 编辑vi /etc/profile： export LC_ALL=&quot;zh_CN.GB18030&quot; 编辑vi /etc/default/locale： #LANG=&quot;zh_CN.UTF-8&quot;#LANGUAGE=&quot;zh_CN:zh&quot;LC_ALL=&quot;zh_CN.GB18030&quot;LANG=&quot;zh_CN.GB18030&quot;LANGUAGE=&quot;zh_CN.GB18030:zh_CN.GB2312:zh_CN&quot;SUPPORTED=&quot;zh_CN.GB18030:zh_CN:zh:en_US.UTF-8:en_US:en&quot;SYSFONT=&quot;lat0-sun16&quot;SYSFONTACM=&quot;8859-15&quot; 添加个人系统变量，当 GNOME 启动后，会读取这个文件里面的设置：vi ~/.profile export G_FILENAME_ENCODING=GB18030export G_BROKEN_FILENAMES=1 注销重新登录或重启生效。 在以上的步骤中用到了vi命令，运行后可以在 shell 环境中编辑文件。著名的 VIM 编辑器就是在 VI 的基础上改进的。以下这些操作可能让你很快上手 VI，比如对路径为/a文件进行编辑。 执行vi /a打开文件，不存在则创建； 按键盘编辑功能键insert使文件进入输入模式，现在可对文件进行修改，像使用任意文本编辑器一样； 按esc退出输入模式，进入指令模式； 输入:wq!对修改的文件进行保存并退出； 如果文件没有进行修改，输入:q退出；如果要放弃修改，输入:q!退出。 参考：Linux下vi命令大全 远程桌面连接阿里云的网页版连接管理终端在图形界面下非常卡，一定让你很不爽。让我们开始有趣的部分吧！ 安装 Xrdp： sudo apt-get install xrdp vnc4server xbase-clients 安装 dconf-editor： sudo apt-get install dconf-editor 运行 dconf-editor： dconf-editor 展开org -&gt; GNOME -&gt; desktop -&gt; remote-access；只打开enabled和notify-on-connect，其他都关掉；修改vnc-password，这是你的远程登录密码；启动远程桌面连接：Windows 上，按win + R运行mstsc；输入你的服务器 IP 和用户名连接；登陆模式选vnc-any，IP和密码输入连接成功。 如果你依然觉得卡的话，可以对远程连接做以下配置。 启动远程桌面连接 -&gt; 显示选项 显示 -&gt; 颜色可进行降级调整，还可以在显示设置调整远程桌面窗口大小 体验 -&gt; 进行连接和功能的降级调整 这些调整需要结合服务器配置和网络条件进行合理的选择。 另外还有一种基于 XFCE 桌面环境的连接方式，这在我第一回合就尝试过，也是可行的。参考：Windows 7远程桌面连接Ubuntu 14.04 Nodejs 安装Nodejs 的安装有很多种，最简单的就是在服务器浏览器里面从 Nodejs 网站中选择对应版本下载，其次还可以下载源码编译以及从软件中心(apt-get)安装等。 我这里使用的是 NVM 安装，它是一个 Node 版本管理器。 安装 Git： sudo apt-get install git 安装 NVM： cd ~/安装路径git clone https://github.com/creationix/nvm.git 设置 NVM 下载源为淘宝镜像： NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/dist nvm install 0.11.11 配置 NVVM 的相关环境变量，编辑~/.bashrc： source ~/git/nvm/nvm.shexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/dist 安装 Nodejs，nvm install version： nvm install v4.2.4 同时可以安装下cnpm，从淘宝镜像安装模块： npm install -g cnpm --registry=https://registry.npm.taobao.org 开始进行服务器连接测试，以下不是必须要做的。 安装 Express 生成器： cnpm install express-generator -g 生成测试应用： cd ~/demoexpress test 安装所有依赖包： cd testcnpm install 启动测试应用： npm start 从本地打开http://服务器IP:3000可以看到 Welcome to Express，就证明服务器连接成功。 感谢 Windows使用VNC viewer访问Ubuntu 14.04远程桌面的简单方法 http://www.cnblogs.com/huangfenghit/archive/2011/05/08/2040201.html 快速搭建 Node.js 开发环境以及加速 npm快速搭建 Node.js 开发环境以及加速 npm 当然，实际参考的文章远比这多的多。不过，是这几篇文章在重要的阶段带我登上云端。遗憾的是安装过程中没有截图，只是凭记忆把这些东西串连起来了，实际操作中难免有误，见谅！","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"Linux","slug":"Linux","permalink":"http://imys.net/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://imys.net/tags/Ubuntu/"}]},{"title":"写一个歌曲下载工具","date":"2016-02-15T08:33:31.000Z","path":"20160215/download-music-by-nodejs.html","text":"最近有朋友找我帮他下载歌曲，果然在其他人眼里，程序员简直是“无所不能”的存在啊。不过，这个需求对于程序员来讲，还算是比较正常的，比那些找你“刷QB”、“盗号”什么的强多了。 要是放到以前下载歌曲，直接回一句“搜百度”完事，近年来歌曲版权逐渐被重视了，一些歌曲逐渐变为会员下载或者收费下载。不过好歹还是可以在线播放的，只要能播放，那想找到歌曲文件就很简单了。 可以从开发者工具 - Network 里找音乐文件的请求链接，或者打开浏览器本地缓存文件夹找大文件。 为了防止以后有朋友发出重复需求，我决定写一个工具出来。 这其中涉及到了跨域访问、页面内容抓取，最终决定用express和cheerio来搞，服务端不存在跨域问题。 试了一些音乐网站的歌曲搜索和播放后，最终把目标瞄准了酷我音乐。 搜索酷我的歌曲搜索就是一个表单提交，页面跳转，服务端直接输出一个包含搜索结果的页面，这个页面的 URL 包含了查询字符串。 http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你 字段type表示搜索类型，也就是该页面上的 7 个标签页。 对应关系如下：all --综合artist --歌手music --歌曲album --专辑mv --MVplaylist --歌单lyric --歌词 对于目前的需求来说，type=music已经足够了。 key是搜索关键字。该页签下还有一个参数pn表示页数，每页最多显示 25 项，该参数省略表示第一页。 该页面的搜索列表和分页均为后端直出，想要封装自己的接口只好获取整个页面内容，然后解析 DOM ，组成自己需要的数据。 模版views/index.html &lt;input type=\"text\" id=\"key\" value=\"曾经的你\"&gt;&lt;button id=\"search\"&gt;搜索&lt;/button&gt;&lt;hr&gt;&lt;ol id=\"list\"&gt;&lt;/ol&gt;&lt;hr&gt;&lt;div id=\"page\"&gt;&lt;/div&gt;&lt;script src=\"http://apps.bdimg.com/libs/jquery/1.9.0/jquery.min.js\"&gt;&lt;/script&gt; 模版使用的 ejs。 路由// 页面渲染app.get('/', function(req, res) &#123; res.render('index', &#123; title: 'Music' &#125;);&#125;);// 搜索app.get('/search/:key/:pn', function(req, res) &#123;&#125;); 实现逻辑很简单，点击搜索时取文本框的值 ajax 请求/search/:key/:pn获取数据渲染#list和#page。 (function () &#123; var $key = $('#key'), $so = $('#search'), $list = $('#list'), $page = $('#page'); function getData(key, pn) &#123; $.getJSON('/search/' + key + '/' + pn, function(data) &#123; // 渲染 #list 和 #page &#125;); &#125; function search() &#123; var key = $.trim($key.val()); if(!key) &#123; return; &#125; getData(key, 1); &#125; $so.click(function () &#123; search(); &#125;); $key.keyup(function(event) &#123; if(event.keyCode === 13) &#123; search(); &#125; &#125;);&#125;.call(this)); 根据前端的需求，后端输出的数据格式应该是这样的。 &#123; list: [], page: ''&#125; 开始封装对应格式的数据。 通过开发者工具 - Elements 可以找到酷我搜索结果页面的列表和分页的 Dom。可以使用 http 模块去请求这个页面，拿到整个页面文档，使用 cheerio 选取对应的 Dom 来组装成我们需要的数据。 歌曲列表的选择器为.m_list ul，分页的选择器为.page。当然，使用类选择器时要确定该类在页面内是唯一的。 // 搜索app.get('/search/:key/:pn', function(req, res) &#123; // http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你&amp;pn=1 var key = req.params.key, pn = req.params.pn, option = &#123; host: 'sou.kuwo.cn', port: 80, path: '/ws/NSearch?' + querystring.stringify(&#123; type: 'music', key: key, pn: pn &#125;), method: 'GET' &#125;; var req2 = http.request(option, function(res2) &#123; var body = ''; res2.setEncoding('utf8'); res2.on('data', function(data) &#123; body += data; &#125;); res2.on('end', function() &#123; // 解析 html var $ = cheerio.load(body), $list = $('.m_list ul li'), $page = $('.page'), list = []; $list.each(function(i, el) &#123; var $this = $(el); list.push(&#123; id: parseInt($this.find('input[name=\"musicNum\"]').val()), name: $this.find('.m_name a').attr('title'), album: $this.find('.a_name a').attr('title'), singer: $this.find('.s_name a').attr('title') &#125;); &#125;); $page.find('a').each(function(i, el) &#123; var $this = $(el), href = $this.attr('href'); if (href !== '#@') &#123; var num = href.split('=').reverse()[0]; $this.attr('data-option', JSON.stringify(&#123; key: key, pn: num &#125;)); &#125; $this.attr('href', 'javascript:;'); &#125;); res.send(&#123; page: $page.html(), list: list &#125;); &#125;); &#125;); req2.on('error', function(e) &#123; console.log(e); &#125;); req2.end();&#125;); 歌曲的数据项取了 id、歌名、专辑、歌手。分页的 Dom 结构比较简单，我直接把分页内的a:href属性替换了，添加自定义数据用于前端点击重渲染，直接返回整个分页的 HTML。 以上代码引用的模块有http、querystring、cheerio。不得不说cheerio用来爬页面实在是太棒了！ 以上代码在一个请求处理逻辑中又发出 http 请求，显然可以封装出一个请求模块，以备其他地方使用。 lib/request.js var http = require('http');module.exports = function(options) &#123; return new Promise(function(resolve, reject) &#123; var req = http.request(options, function(res) &#123; var body = ''; res.setEncoding('utf8'); res.on('data', function(data) &#123; body += data; &#125;); res.on('end', function() &#123; resolve(body); &#125;); &#125;); req.on('error', function(e) &#123; reject(e); &#125;); req.end(); &#125;);&#125; 添加一个 request 模块用于 http 请求，以 Promise 方式返回。这样搜索的处理逻辑代码就变成这样。 app.get('/search/:key/:pn', function(req, res) &#123; // http://sou.kuwo.cn/ws/NSearch?type=music&amp;key=曾经的你&amp;pn=1 var key = req.params.key, pn = req.params.pn, option = &#123; host: 'sou.kuwo.cn', port: 80, path: '/ws/NSearch?' + querystring.stringify(&#123; type: 'music', key: key, pn: pn &#125;), method: 'GET' &#125;; request(option).then(function(body) &#123; // 解析 html var $ = cheerio.load(body), $list = $('.m_list ul li'), $page = $('.page'), list = []; $list.each(function(i, el) &#123; var $this = $(el); list.push(&#123; id: parseInt($this.find('input[name=\"musicNum\"]').val()), name: $this.find('.m_name a').attr('title'), album: $this.find('.a_name a').attr('title'), singer: $this.find('.s_name a').attr('title') &#125;); &#125;); $page.find('a').each(function(i, el) &#123; var $this = $(el), href = $this.attr('href'); if (href !== '#@') &#123; var num = href.split('=').reverse()[0]; $this.attr('data-option', JSON.stringify(&#123; key: key, pn: num &#125;)); &#125; $this.attr('href', 'javascript:;'); &#125;); res.send(&#123; page: $page.html(), list: list &#125;); &#125;, function(e) &#123; console.log(e); &#125;);&#125;); 数据有了，开始写前端页面渲染部分。 function getData(key, pn) &#123; $.getJSON('/search/' + key + '/' + pn, function(data) &#123; var body = ''; data.list.forEach(function (v, i) &#123; body +='&lt;li&gt;&lt;a href=\"download/'+ v.id +'\"&gt;'+ v.name +' '+ v.album +' '+ v.singer +'&lt;/a&gt;&lt;/li&gt;'; &#125;); $list.html(body); $page.html(data.page); &#125;);&#125; 每次调用这个方法都会获取数据渲染列表和分页。歌曲列表的每一项直接使用了 a 链接，点击直接下载歌曲，会有一个新的路由/download/:id。 分页内的 a 链接已经加上了自定义数据，直接添加点击事件拿到数据调用getData方法。 $page.on('click', 'a[data-option]', function () &#123; var option = $(this).data('option'); getData(option.key, option.pn);&#125;); 至此，搜索加分页就全部完成了。 下载在酷我的页面中点击歌曲名可以跳转到一个歌曲播放页，该页面 URL 格式为http://www.kuwo.cn/yinyue/100062/，其中的 100062 就是歌曲ID了。对于资源文件，直接分析 Network，找到资源文件请求和歌曲ID之间的关系，期望可以直接获取到资源文件的链接。 最终分析结果： ID100062 的资源文件名是 1058000744.aac。有一个请求 http://antiserver.kuwo.cn/anti.s?rid=MUSIC_100062&amp;format=aac|mp3&amp;type=convert_url&amp;response=url 的结果为 http://win.web.ra03.sycdn.kuwo.cn/07baab80f0a6dd9b3a091879b308ae68/56c2840e/resource/a1/48/63/96/1058000744.aac。 这样我们直接用歌曲ID去请求http://antiserver.kuwo.cn/anti.s就能获得歌曲链接了。 酷我的默认请求为.aac格式，应该是和参数format=aac|mp3有关，可以改成format=mp3|aac。 app.get('/download/:id', function(req, res) &#123; // http://antiserver.kuwo.cn/anti.s?rid=MUSIC_100062&amp;format=aac|mp3&amp;type=convert_url&amp;response=url var option = &#123; host: 'antiserver.kuwo.cn', port: 80, path: '/anti.s?rid=MUSIC_' + req.params.id + '&amp;format=mp3|aac&amp;type=convert_url&amp;response=url', method: 'GET' &#125;; request(option).then(function(body) &#123; res.redirect(body); &#125;, function(e) &#123; console.log(e); &#125;);&#125;); request 模块又派上用场了，由于该请求直接返回了歌曲链接，我就直接重定向到该链接了。为了使歌曲在新窗口打开，前端页面列表项中的 a 链接要添加target=&quot;_blank&quot;。 成果展示截图 CodeGithub - DownloadMusic","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"express","slug":"express","permalink":"http://imys.net/tags/express/"},{"name":"cheerio","slug":"cheerio","permalink":"http://imys.net/tags/cheerio/"}]},{"title":"我为什么选择了前端？","date":"2016-02-07T05:43:14.000Z","path":"20160207/end-2015.html","text":"初出茅庐前年的腊月二十九我接到了上传简历后的第一个面试通知，于是去年初六没到，我就收拾好东西来郑州了。 我当时的求职意向写的是：.NET/JAVA/前端。不知道哪儿来的自信，我就是感觉自己干什么都可以。我从来都觉得一个程序员不应该被语言和技术所标记。在这个行业，学习能力决定了你能走多远。 事实上，我根本就是一个刚出炉的菜鸟。那个时候已经有一年多的码龄，看起来什么都会点，也能写出一些让初学者感觉叼炸天的东西来。可是对于很多东西的理解都不够深，感觉就是学了一些杂七杂八的招式，所知种种也都还在基本应用的层面。这些也终于在面试的时候暴漏了。 由于我的求职岗位多，面试机会也多。写简历的时候还想把安卓也写上，尝试写过一个APP，感觉代码跟 java swing 差不多，上手也不难。当时跨平台呼声很大，还是决定走 WEB 路线。 面试挫折不到一周的时间，大概面试了六七家公司，现在所在是面试的第三家。并不是这家公司的待遇有多好，而是有一家公司打击到了我（虽然我不服）。 那家公司面试的是前端，还是我比较看好的一家。懂后端的去面试前端一般是很受欢迎的，我也这么认为的。虽然当时对于原型、作用域、闭包等一些进阶知识都一头雾水，但是我还是玩出了 java 编程的感觉。我还写了类、对象、继承、简单工厂模式，硬是用 js 实现了一个棋牌游戏的规则。最后导师告诉我，面向对象运用的不错，编程套路是不区分语言的，但是规则如果写到前端是不是就不安全了。也对，我开个控制台，改点变量不就无敌了。 所以说，当时的我对于面试前端有着盲目的自信。 一到那边就开始做笔试了。该公司逼格很高，两套面试题，一套中文，一套英文，我当时懵逼了。然后向 HR 确认可以不做英文才放下了心。这显然是一个对英语水平的检测，至于我的英文水平？我可以这么说，谷歌懂的我都懂！ 面试题也都很基础，比如 HTML 标签的使用（考察文档结构语义化）、HTML5 和 CSS3 常用标签和属性（考察对新技术的了解）、实现某种需求要如何写样式（考察基本功）、如何解决某种页面 兼容性问题（考察经验）、js 语言基础和 jquery 的一些属性和方法的掌握（也是基本功），还有判断 js 代码的执行结果（考察对 js 语言的掌握）。 我是一题不落的写完了，不求对，只求完整。在写题的过程中我已经发现了自己的不足。主要是页面兼容性和 js 语言基础。学习过程中都是后端为主，作为处女座，前端我也会用CSS3、jq特效以及bootstrap之类的框架打扮的漂漂亮亮的。我怎么可能去想什么页面兼容性问题。写 js，大概除了判断、循环、定义变量和函数就全是一股脑儿 jq 了。 不足是不足，我相信这些我都是可以在以后的工作中快速掌握的。我还是对面试成功抱有希望的。 做完面试题后，HR 叫了一个小伙子进来，看来是要进行真正的考验了。说一下印象深刻的几个问题。 问我为什么要做前端？的确，我的简历上后端技术居多，不知道一些人是不是会以为我是二傻子。我脱口而出：前端好玩！这是来自心底的答案。 难道前端不好玩吗？用 winform、swing 写界面的时候太痛苦了。而在前端简直就没有实现不了的，加上新的 h5、css3 又让网页增添许多表现力。学后端不代表我不关注前端，通过一些技术社区和博客，我可是知道前端进入了一个怎样的时代。这让我感觉前端大有可为！这也是我在求职意向写上前端的理由之一。还有一个理由是 CURD 写烦了，前端直接处理数据合理的展示给用户，更能有成就感！ 问了一个我从来没有关心过的问题，js 有哪几种基本数据类型？我回答的是：整型、浮点型、布尔型和字符串，还是十分肯定的语气。从后端的角度考虑，基本类型就是不需要用new来声明，因为知道有一个parseFloat函数，理所当然的以为float是一种数据类型。而正确答案中的undefined、null居然会是数据类型，这对于使用强类型语言的我根本是难以理解的。 还现场看了我的代码，就是棋牌游戏那个。开头就指着$().ready(function(){ })说我写的不对，$()里面应该写参数、写window。我不置可否。然后对我写的类和继承提出质疑。继承的实现有多种，我还是知道的。我写的这种应该是少见的，但也不至于说有什么错误。直到我现在看看当时的代码，都比我们公司后端写的 js 强多了。 问了我 js 常用的函数以及调用方式。我回答的不够好，平常还是太依赖 jq，或者使用的时候查文档。一些答案都是猜的，因为语言的共通性，你几乎可以确定 java 中某些类的一些函数，js 中也有。 我说用的时候查下不就行了，他说你查哪儿，我说 w3cSchool。然后我清楚的记得他那写满一脸 hehe 的表情。:-) 最后是现场编码，冒泡排序。我当时也是慌了，连个冒泡都没写正确，面试完下楼才恍然大悟，是内层循环条件写错了。 他问我有没有什么问题要问他的。我一脸微笑的看着他，问：你工作多久了？ :-)他一脸不爽，有点不耐烦的说：2年了。 一 一+ 走的时候 HR 说回去等通知，结果半路上就收到短信给我画上句号了。 阴差阳错之后的几个面试也不理想，郑州很多小作坊的网络公司，进去就是坑。 而我现在所在的公司，当时给我的工资真的不高，完全就是把我当初学者。我最初去的时候以为面试的职位是 .NET，每个要面试的公司我都会提前做功课了解该公司行业和技术类别。结果来面试我的人，就是我现在的领导，也就是说是叫我来做前端。 也没做什么笔试，不过登记表填了半天，查户口一样。面谈也没问我什么特别难的问题，更多的是问了我对新技术的了解。这点我还是很让人满意的，并且我表现出了足够的兴趣。“一谈技术，两眼放光”，说的就是那时的我了。领导还是我的老乡。 第二次去的时候，就是在之前的面试失败之后了。 那天回去之后我就把面试中存在的疑问查找了下答案。对于这样的面试结果虽然不满意，但是却萌发了我走前端之路的心思。陌生的领域往往有着致命的诱惑。如果说现在有游戏开发的工作愿意要我，给我较低的工资我也愿意去。 这次来就是确定意向的。 因为薪资给的低，我问到了涨薪制度。他表示半年涨一次固定薪资。我继续追问了有没有可能给予优秀的人涨更高的工资，我表示自己能够快速的成长起来。他表示如果试用期表现好，可以涨多点。 最后他介绍了下公司状况以及行业地位，以及当前团队正在进行的项目，并且向我表示有移动端开发项目。当我知道目前他们团队，也就是我现在的团队，正在做整站改版的时候，我决定留下来了。既然我要踏入前端，那么这次整站改版就是一次很好的实践机会，应该可以从头到尾系统的学习很多东西。就当是一次发工资的培训了。 好像有点混乱，我也忘了是一次谈好还是去了两次。 焉知非福最后不谦虚的说，我们公司是真的赚到了。目前公司 3 个前端，js 基本都是我写的，或者是他们俩复制我的代码到其他地方。我承担了前端的大部分工作，在后端的配合上也有着绝对的优势。 我也赚到了，因为这个平台，让我完成了很多实践。反正这里前端没有比我强的，也不怕有人对我有何见教。 这个 MD 是年前创建的，直到今天我才写完。╮(╯▽╰)╭","tags":[{"name":"前端","slug":"前端","permalink":"http://imys.net/tags/前端/"},{"name":"面试","slug":"面试","permalink":"http://imys.net/tags/面试/"}]},{"title":"我刚知道的 Promise","date":"2016-02-03T03:19:47.000Z","path":"20160203/js-promise.html","text":"有时候，你会发现满世界都是某个字眼。 Promise，就是这个家伙。简直阴魂不散，走到哪儿都能看到它。fetch、koa中都有TA的身影，而我却对TA一无所知。搜索TA的文章介绍，第一页中最早的一篇文章已经是2011年了。那是个我还不会HelloWorld的年代啊！ 用法Promise 对象用于延迟(deferred) 计算和异步(asynchronous ) 计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。 看概念很迷糊，直接看实例理解吧。 function $http(url)&#123; var core = &#123; ajax : function (method, url, args) &#123; var promise = new Promise( function (resolve, reject) &#123; var client = new XMLHttpRequest(); var uri = url; if (args &amp;&amp; (method === 'POST' || method === 'PUT')) &#123; uri += '?'; var argcount = 0; for (var key in args) &#123; if (args.hasOwnProperty(key)) &#123; if (argcount++) &#123; uri += '&amp;'; &#125; uri += encodeURIComponent(key) + '=' + encodeURIComponent(args[key]); &#125; &#125; &#125; client.open(method, uri); client.send(); client.onload = function () &#123; if (this.status &gt;= 200 &amp;&amp; this.status &lt; 300) &#123; resolve(this.response); &#125; else &#123; reject(this.statusText); &#125; &#125;; client.onerror = function () &#123; reject(this.statusText); &#125;; &#125;); return promise; &#125; &#125;; return &#123; get : function(args) &#123; return core.ajax('GET', url, args); &#125;, post : function(args) &#123; return core.ajax('POST', url, args); &#125;, put : function(args) &#123; return core.ajax('PUT', url, args); &#125;, delete : function(args) &#123; return core.ajax('DELETE', url, args); &#125; &#125;;&#125;;$http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; // success&#125;, function(data)&#123; // error&#125;); 以上是一个基于 Promise 的 ajax 实现，调用形式跟 vue-resource 如出一辙（果然又是大神们嚼烂的玩意儿）。 Promise 的构造函数可以带有1个参数，它是带有resolve、reject两个参数的函数对象，如以上core.ajax函数中创建的 Promise 对象。其中 resolve 用于处理执行成功的场景，reject 用于处理执行失败的场景。在成功与失败的处理阶段 hook 到一个 Promise 对象中，最后通过then方法来真正的处理返回结果。 Promise.prototype.then(onFulfilled[, onRejected]) Promise.prototype.catch(onRejected) 并不是所有的失败场景都需要在then方法中处理，在其后继续追加catch方法也是可以的。 $http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; // success&#125;).catch(function(data)&#123; // error&#125;); 由于then和catch仍然返回一个 Promise 对象，所以可以出现多个then或catch来处理不同的业务场景。 $http('http://url/api').get(&#123; id: 111&#125;).then(function(data)&#123; return handleA(data);&#125;).then(function(data)&#123; // 此处 data 为 handleA 方法处理后的数据 return handleB(data);&#125;); 为何要用咋一看 Promise 就是一个包装好的代理对象。不过它的出现究竟是为了解决什么问题呢？ 在 Promise 出现之前，如果你的逻辑中出现了异步操作，而又需要在异步操作外获取异步操作内的结果，不外乎是要使用回调了。 function getList(callback) &#123; $.get(yourApi, function(data)&#123; callback(data); &#125;);&#125; 使用 Promise 呢？ function getList() &#123; return new Promise( function (resolve, reject) &#123; $.get(yourApi, function(data)&#123; resolve(data); &#125;).error(function(data)&#123; reject(data); &#125;); &#125;&#125; 使用 Promise 代理了原来所需要的回调的，返回一个对象而不是传入回调参数的方法形式更直观和容易理解。在之后的编程中，当目标方法返回了一个 Promise 对象，我们就知道发生了异步操作，需要通过 then 方法来处理场景需求。 到此为止，Promise 给我的感觉也只不过是语法糖罢了，这种形式的写法我也可以封装出来啊。接下来才是其真正的优点。 比如异步处理多个的请求结果，原始写法。 function getData(callback)&#123; $.get('/ApiA', function(dataA)&#123; $.get('/ApiB', function(dataB)&#123; $.get('/ApiC', function(dataC)&#123; callback(dataA, dataB, dataC); &#125;); &#125;); &#125;);&#125; 当然以上是一种比较蠢的写法，当请求数量发生变化时的时候，这段代码就需要修改了。可以用递归优化下。 function getData(url, callback)&#123; if(url instanceof Array) &#123; var i = 0, len = url.length, dataArr = [], eachLoad = function(url)&#123; $.get(url, function(data)&#123; dataArr.push(data); if(i++ &lt; len - 1) &#123; eachLoad(url[i]); &#125; else &#123; callback.apply(null, dataArr); &#125; &#125;); &#125;; eachLoad(url[i]); &#125; else &#123; $.get(url, function(data)&#123; callback(data); &#125;); &#125;&#125; 使用 Promise 解决。 var promiseA = $http('/List').get(&#123; id: 111 &#125;), promiseB = $http('/List').get(&#123; id: 222 &#125;);Promise.all([promiseA, promiseB]).then(function(data)&#123; // do...&#125;); 使用Promise.all方法一次性处理多个操作。 Promise 属于 ES6 特性，目前在 IE 中还不能用，不过各大框架也都有自己的实现。 jQuery 中的 PromisejQuery 中很多异步操作都会返回一个延迟对象$.Deferred，该对象具有一系列的操作方法。 // animate$('div').animate(&#123; width: '50%'&#125;, 300).done(function()&#123; // 当延迟成功时调用&#125;);// ajax$.get('/List').then(function()&#123; // succee&#125;, function()&#123; // error&#125;);// when$.when($.ajax('/List1'), $.ajax('/List2')).then(function()&#123; // succee&#125;, function()&#123; // error&#125;);// 还有很多，可以去 jQuery Api 中看。 参考 javascript标准库-Promise | MDN JavaScript异步编程的Promise模式 JavaScript Promise迷你书","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"http://imys.net/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://imys.net/tags/promise/"},{"name":"async","slug":"async","permalink":"http://imys.net/tags/async/"}]},{"title":"你以为你写的1px就是1px吗？","date":"2016-01-27T14:33:05.000Z","path":"20160127/mobile-1px.html","text":"“这一行的分割线高了一点。”好的，减小行高, 加点上下内边距。 “这几个元素要两端对齐。”好的，flex没有解决不了的布局，justify-content: space-between;搞定。 …… “这个图标颜色不对，应该是#999。”好的，我改…等等，明明就是 #999 啊，这分明是想被打脸的节奏。打开页面，右键图标，审查元素，截图。是不是 999 ？是不是 999 ？？是不是 999 ？？？ “所有的下边框都应该是1px。”我看到这个问题的瞬间，感觉像在侮辱我的智商。边框 1px 这么常用的样式，我还会写错不成？ 正当准备继续“打脸”时，突然我的好奇心上来了。关于 1px 边框在移动设备上看起来比较粗 这个问题，我也曾经想过。因为页面其他内容看起来都是正常的，所以我一直觉得这是移动设备浏览器的渲染问题，属于外部原因。也曾设置过 .5px ，但显然浏览器并不买账。 搜索关键字1px border，找到了问题所在。 devicePixelRatio说来惭愧，关于 devicePixelRatio，我也算是有使用经验的人了，怎么就没有想到呢。 简单举例一下，我的 MX5 分辨率是 1920*1080，但是实际屏幕物理像素是 640*360，换算得出 devicePixelRatio = 3。也就是说屏幕中的1点 = 3px。 设计师提出的图标颜色不对的问题也在于此，因为颜色也受益于分辨率。 viewport这一切都是 viewport 在作怪！ 我们在开发手机页面时，都会这样设置。 &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt; width=device-width: 设置浏览器内容宽度为设备物理像素宽度。 initial-scale=1: 缩放比为1，后面两个属性为最大和最小缩放比。 user-scalable=no: 禁止用户手动缩放。 用 1920*1080 分辨率的手机打开一个没有添加 viewport 的PC站点，横屏状态是可以完整的出页面内容的。因为这个时候的 1px 就是 1px。 还原分辨率知道了问题的原因就对症下药了。 可以根据window.devicePixelRatio来动态修改屏幕缩放比，还原真实分辨率。还有一个问题。 分辨率还原了，那岂不是所有元素的尺寸数值都需要重新计算了？如果你的 css 没有使用 em 和 rem 为单位的话，那么恭喜你，一个一个慢慢改吧。而使用 em 和 rem 为单位就简单多了，只需要动态修改根元素字体大小就行了。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;&lt;%=title %&gt;&lt;/title&gt;&lt;meta id=\"vp\" name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\"&gt;&lt;script&gt;(function () &#123; var vp = document.getElementById('vp'); dpr = window.devicePixelRatio, html = document.getElementsByTagName('html')[0], vpVlue = 'width=device-width, initial-scale=X, maximum-scale=X, minimum-scale=X, user-scalable=no'; if(dpr) &#123; vp.content = vpVlue.replace(/X/g, (1 / dpr)); html.style.fontSize = (14 * dpr) + 'px'; &#125;&#125;)();&lt;/script&gt;&lt;head&gt; 这可以直接加到头部模版中。 关于修改根元素字体大小也可以使用 css媒体查询的方式。 @media (-webkit-min-device-pixel-ratio: 2) &#123; html &#123; font-size: 28px; &#125;&#125;@media (-webkit-min-device-pixel-ratio: 3) &#123; html &#123; font-size: 42px; &#125;&#125; 彩蛋本来 js 代码我是放到 body 闭合前的。viewport 初始缩放值是 1 ，根元素初始字体大小是 14px，我的手机 devicePixelRatio 是 3。按照浏览器加载顺序，等执行到 js 前，页面内容应该 1/3 的大小；执行完 js 后，页面恢复实际大小，整个页面居然出现了类似于transform: scale(1)般的过渡效果。 为了让用户更早的看到页面内容，我还是决定放到头部了。 问题更新以上的思路和代码确实解决了问题，至少我在手机浏览器上测试是OK的。之后在 APP 中嵌入后发现没有效果，页面内容都因为字号修改被放大了。我怀疑是安卓端的某些配置的原因，但是不了解的事又不好乱发言。 最后抽了一个闲工夫，把安卓环境搭了起来，看着 WebView 的API，自己写了个测试DEMO。问题解决了。 webview.getSettings().setUseWideViewPort(true); // 自适应手机屏幕 从方法名就很容易理解这个配置项与 viewport 存在着关系。问题解决了，我要去安卓那边装逼了。","tags":[{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"mobile","slug":"mobile","permalink":"http://imys.net/tags/mobile/"},{"name":"devicePixelRatio","slug":"devicePixelRatio","permalink":"http://imys.net/tags/devicePixelRatio/"},{"name":"webview","slug":"webview","permalink":"http://imys.net/tags/webview/"},{"name":"viewport","slug":"viewport","permalink":"http://imys.net/tags/viewport/"},{"name":"em","slug":"em","permalink":"http://imys.net/tags/em/"}]},{"title":"Hexo博客改版记录","date":"2016-01-18T01:02:18.000Z","path":"20160118/hexo-blog-update-log.html","text":"每当我把之前立下的 flag 执行的时候，都感觉是一件很骄傲的事，太多的计划被我用各种接口扼杀在摇篮中了。 引言在 Android 更新到 5.0 后，我就对触摸反馈这一点很感兴趣。也尝试模拟过，但是最后的效果都不太满意。偶然的一次在 github上 看到了 Materialize 这个项目，才知道了谷歌的Material Design(原质化设计) 设计规范。而后在公司听到设计师提到这个东西时，突然有种跟上了潮流的感觉。 就像一些文章中提到的，即使你不懂设计，但是照着样式去做，也不会太丑。这显然很对我的胃口。 改版内容除了博客风格改版外，也改变了以下一些内容。 Hexo toc在我刚使用 Hexo 不久时，还曾专门写了一篇文章介绍 hexo-toc 插件的使用。不过最近在我升级了 hexo-toc 插件后，发现已经不需要像我写的那么麻烦了。这还不是重点。因为博客布局结构要有很大变化，很多模版我都需要重写。所以就需要查阅 Hexo 文档寻找一些可利用的资料。就在这个过程中，我居然发现了 Hexo 居然有生成 toc 的辅助方法。好气好气，也不是第一次翻文档了，之前居然都没注意到。 与 hexo-toc 插件比，这个辅助方法更加便利。文档链接hexo-toc 需要在编辑时插入&lt;!--toc--&gt;标记，且生成后的内容还在文章中占位。这对于想实现一些浮动式文章导航的同学十分不便。而&lt;%- toc(str, [options]) %&gt;方法就简单多了，只要是在文章页中，你放到什么地方，就在什么地方渲染。 去 jquery仅仅是一个博客，也没有多少复杂的 Dom 操作。读者也都是程序猿，也不存在要考虑浏览器兼容。jquery 能不用则不用，当前的 js 也就写了100多行。 去 fancyboxfancybox 是基于 jquery 的一个图片浏览插件，jquery 去了，它自然也就失效了。请求数挺多的,而且它本身的功能，我并不在意，没什么卵用的感觉。如果后续有需要，也可以用原生实现一个。 去 stylus, 用 less这个纯粹是个人的习惯。html 和 css 还是喜欢原生的代码风格，stylus 和 jade 这种强缩进的都不太喜欢。 替换时需要在配置文件中增加 less 插件的依赖和参数配置。 plugins: - hexo-renderer-lessless: paths: - source/css/style.less 安装 roboto 字体Roboto 字体是 Material Design 的推荐英文字体。英文字体文件字节小，毕竟只有26个字母。虽然写不了几个单词。中文推荐字体是 Note，但是要115.5MB。Google Note Fonts 增加 Waves 效果这个也是 Material Design 提倡的响应式交互效果。Materialize 中使用的是 Waves。我也是顺藤摸瓜才知道了这个库。 分享现在的文章分享是直接通过 JiaThis API 接口，不需要引用额外的js。这样DIY就更方便了。默认的分享样式，很难实现一些效果。像我现在的分享，有文章右侧的静态挂件和顶部浮动导航右侧的分享按钮。 最后我不懂设计，所以关于 Material Design 的介绍，也就不多提。附上参考链接，有兴趣的可以去提高一下审美。 Google Material design Material Design 中文版 Material design的实现：Materialize 一些小细节还会不断的调整，之后整理下再把主题发布到 github 上。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"material","slug":"material","permalink":"http://imys.net/tags/material/"}]},{"title":"前端技术模拟移动端wheelview滑动选择器","date":"2015-12-31T01:59:48.000Z","path":"20151231/simulation-of-wheelview-selector.html","text":"公司进入APP改版阶段了，会基于原生安卓开发，感觉没自己什么事了。只能看看原型图，想想前端技术如何实现某某功能。。。 滑动选择器在APP上是很常见的组件了，最初是 IOS 上的组件，之后就出现 Android 版的自定义实现，称为 WheelView。对于前端技术来讲，实现也并不困难。 布局是解决复杂组件效果的关键，要充分结合css去思考。 选中项和未选中项的样式不一致是首先要解决的问题，最终想到了两种解决方案。 Plan A&lt;div class=\"wheelview\"&gt; &lt;div class=\"action\"&gt; &lt;a href=\"javascript:;\" class=\"fl\"&gt;取消&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"fr\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul class=\"backlist list\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"front\"&gt; &lt;ul class=\"list\" id=\"front\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用两个列表来显示，一个列表作为背景显示所有项；另一个列表置于顶层，固定为一行的高度显示选中项。需要处理两个列表的同步滚动。 Plan B&lt;div class=\"wheelview\"&gt; &lt;div class=\"action\"&gt; &lt;a href=\"javascript:;\" class=\"fl\"&gt;取消&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"fr\"&gt;确定&lt;/a&gt; &lt;/div&gt; &lt;div class=\"wrap\" id=\"wrap\"&gt; &lt;ul class=\"list\"&gt; &lt;li&gt;一年-两年&lt;/li&gt; &lt;li&gt;两年-三年&lt;/li&gt; &lt;li&gt;三年-五年&lt;/li&gt; &lt;li&gt;五年-八年&lt;/li&gt; &lt;li&gt;八年-十年&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"top\"&gt;&lt;/div&gt; &lt;div class=\"bottom\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 单列表显示，再添加两个同级的遮罩层设置透明色渐变，分别覆盖于列表上下，保留中间一项的视区。 根据不同应用场景，两种方案各有千秋。 Plan A ：适用于选中项与普通项样式差别大的场景。比如选中项要求为蓝色，普通项为灰色，已经不在一个色系了。Plan B ：单列表结构更清晰，节省标签。亮点就是遮罩层的渐变背景色。 最后只剩下实现滚动效果了，为防掉坑，引用了 iscroll.js。 Code","tags":[{"name":"mobile","slug":"mobile","permalink":"http://imys.net/tags/mobile/"},{"name":"wheelview","slug":"wheelview","permalink":"http://imys.net/tags/wheelview/"},{"name":"component","slug":"component","permalink":"http://imys.net/tags/component/"},{"name":"iscroll","slug":"iscroll","permalink":"http://imys.net/tags/iscroll/"}]},{"title":"iconfont兼容与维护","date":"2015-12-23T05:47:34.000Z","path":"20151223/iconfont-maintained.html","text":"在扁平化网页设计中，字体图标有着很好的易用性。结合一年的实际运用，来做一下总结。 使用可以直接引用开源的第三方字体样式文件，如Font Awesome等。或者你想要构建一套产品专属的图标，可以注册一个字体图标库，添加一个图标项目，进行创作和使用。 我司使用的字体库是阿里的iconfont。 设计图标我不懂，都是设计师负责产出的。产出后，可以看到图标的Unicode和font class。 使用时，需要把字体引用@font-face复制到项目公共样式中，可以使用在线字体链接或者下载到本地服务器，然后可以选择两种方式引用。 1.直接使用Unicode.icon &#123; display: inline-block; font-family: \"iconfont\"; font-style: normal; font-weight: normal; -webkit-font-smoothing: antialiased;&#125; &lt;i class=\"icon\"&gt;&amp;#xe74e;&lt;/i&gt; 把Unicode直接写入页面内容中，渲染出图标。 2.使用font class[class^=\"icon-\"]:before, [class*=\" icon-\"]:before &#123; text-decoration: inherit; display: inline-block; speak: none;&#125;.icon-search:before &#123; content: \"\\f002\";&#125; &lt;i class=\"icon-search\"&gt;&lt;/i&gt; 利用伪元素的content属性，把Unicode写到 css 中，不过渲染后还是会在页面展示。 维护由于要IE7不支持伪元素，所以我们这一直是直接使用Unicode的方式引用图标。随着图标的增加，使用极其不方便。 写页面时每次引用图标就需要打开图标项目页面去复制 Unicode，这个真心记不住啊！ 领导抽风要修改图标，然后图标改过之后 Unicode 发生了变化，然后就需要苦逼的把所有使用这个图标的页面都改一遍 Unicode，还好有 gulp-replace。 当我意识到这是一个大坑时，已经来不及了。。。 在之后，我开始基于字符映射的方式去管理字体图标。 在项目里加了一个图标配置文件。如： &#123; \"search\": \"xe74e\", // ...&#125; 前端模版入口会直接把这个图标数据加入页面上下文。由于配置文件定义了语义化的命名，页面使用就方便多了。 &lt;i class=\"icon\"&gt;&amp;#&lt;%=icon.search %&gt;;&lt;/i&gt; 我这边后端是 .net，不管是什么语言，都只需要在公共类中加个读取图标的方法。这样前端的模版拿到后端也不需要进行什么修改。 然而直接促使我发此文的原因是因为不小心点开了 Font Awesome 用于兼容 IE7 的 css 文件。 .icon-file &#123; *zoom: expression( this.runtimeStyle['zoom'] = '1', this.innerHTML = '&amp;#xf016;' )&#125; expression 是 ie 特有的 css 属性，可以在其中写 js 脚本。这样又把图标的维护权交还 css 了。 在 css 中写 js 这种做法肯定是不提倡的，而且一个页面上存在很多的图标，在 ie7 这么恶劣的环境中，渲染速度也是个大问题。我用 IE7 打开 Font Awesome 的页面，速度在30s左右。 这是个问题，又不算问题。但凡是可以让客户反感 ie 浏览器的问题，都是好问题。","tags":[{"name":"iconfont","slug":"iconfont","permalink":"http://imys.net/tags/iconfont/"}]},{"title":"神奇的eval()与new Function()","date":"2015-12-22T05:07:00.000Z","path":"20151222/eval-with-new-function.html","text":"在需要兼容IE8以下的日子里，往往需要使用eval()来把后端传过来的JSON串转成可操作的JSON对象。直到昨天在翻看jQuery源码时，才发现jQuery.parseJSON的兼容实现用的是new Function()。马上Google了相关资料，寻找两者的区别。 evaleval接受字符串参数，解析其中的js代码。如果编译失败，会抛出异常，否则执行其中的代码，计算返回值。 eval('2+2'); // 4eval('console.log(\"ok\")'); // ok 在实际应用中，通常这样转换JSON。 var jsonStr = '&#123; \"age\": 20, \"name\": \"jack\" &#125;';eval('(' + jsonStr + ')'); 为什么要加括号呢？ 因为js中{}通常是表示一个语句块，eval只会计算语句块内的值进行返回。加上括号就变成一个整体的表达式。 console.log( eval('&#123;&#125;') ); // undefindconsole.log( eval('(&#123;&#125;)') ); // Object &#123;&#125; 使用eval需要注意执行作用域 var s = 1;function a() &#123; eval('var s=2'); console.log(s);&#125;a(); // 2console.log(s); // 1 在局部环境使用eval便会创建局部变量。可以显示指定eval调用者来改变上下文环境。 var s = 'global';function a() &#123; eval('var s = \"local\"'); console.log(s); // local console.log(eval('s')); // local console.log(window.eval('s')); // global&#125; Function在之前我对于Function的了解只限于“定义方法的一种非主流方式”。却忽略了Function与eval相同的字符串参数特性。 语法：var func = new Function(arg1, arg2, ..., functionBody); 实例： var add = new Function('a', 'b', 'return a+b;');console.log( add(2, 3) ); // 5 由于其形参使用字符串的方式表示，也可以使用1个字符串来描述多个形参。 var add = new Function('a, b', 'return a+b;');console.log( add(2, 3) ); // 5 在转换JSON的实际应用中，只需要这么做。 var jsonStr = '&#123; \"age\": 20, \"name\": \"jack\" &#125;', json = (new Function('return ' + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。如果可以，请用更好的方法替代。 在一些特殊的运用场合，也有一些合理运用的实践。比如模板解析等。 那么为什么 jQuery 要用new Function而不用eval呢？看看老外做的两者以及原生方法的性能比较：JSON Performance comparison of eval, new Function and JSON","tags":[{"name":"Function","slug":"Function","permalink":"http://imys.net/tags/Function/"},{"name":"eval","slug":"eval","permalink":"http://imys.net/tags/eval/"},{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"优雅的模拟表单元素radio、checkbox","date":"2015-11-13T00:51:49.000Z","path":"20151113/simulation-of-native-radio-checkbox.html","text":"公司内部管理系统准备改版，最近几天把前端架子搭起来了。在规划底层元素时参考了Bootstrap和Amaze UI，一些组件的实现确实很优雅。比如Amaze UI 的单/复选框。 之前我在模拟单/复选框时，都是很暴力的用 js 解决。 绑定点击事件； 更改 checked 属性值； 切换 class 变更样式。 而打开控制台观察Amaze UI的单/复选框，发现Elements状态是无更改的。更改checked属性值，并不会影响到标签字面量属性。但是想要切换选中和未选中的样式，如果不是通过切换class来实现，那便是直接修改DOM了，而这两种操作在控制台中的都能看到一个状态变化的响应。 那么Amaze究竟是怎么实现的呢？ 我选中一个元素的图标，在Styles中观察样式变化。直到发现了伪类选择器:checked和相邻选择器+，才恍然大悟。 实例&lt;label for=\"sex1\" class=\"form-check\"&gt; &lt;input type=\"radio\" id=\"sex1\" checked name=\"sex\" value=\"1\"&gt; &lt;span class=\"check-icons\"&gt; &lt;i class=\"icon icon-check\"&gt;&amp;#xe632;&lt;/i&gt; &lt;i class=\"icon icon-uncheck\"&gt;&amp;#xe634;&lt;/i&gt; &lt;/span&gt; 男&lt;/label&gt;&lt;label for=\"sex2\" class=\"form-check\" &gt; &lt;input type=\"radio\" id=\"sex2\" name=\"sex\" value=\"0\"&gt; &lt;span class=\"check-icons\"&gt; &lt;i class=\"icon icon-check\"&gt;&amp;#xe632;&lt;/i&gt; &lt;i class=\"icon icon-uncheck\"&gt;&amp;#xe634;&lt;/i&gt; &lt;/span&gt; 女&lt;/label&gt; 图标使用的iconfont，然后添加一些样式，我使用less作为css预处理语言。 .form-check &#123; display: inline-block; position: relative; margin-right: 1em; padding-left: 24px; line-height: 28px; cursor: pointer; input &#123; display: none; &amp;:checked+.check-icons &#123; .icon-check &#123; display: inline-block; &#125; .icon-uncheck &#123; display: none; &#125; &#125; &#125; .check-icons &#123; position: absolute; top: 5px; left: 0; width: 18px; height: 18px; text-align: center; .icon &#123; position: absolute; top: 0; left: 0; line-height: 18px; font-size: 18px; &#125; .icon-uncheck &#123; color: #d7d7d7 &#125; .icon-check &#123; color: #4776c8; display: none; &#125; &#125;&#125; 通过label:for属性来触发input:checked属性值更改。 设置相邻选择器，由:checked状态变化影响对应的icon显示和隐藏。 兼容性相邻选择器+兼容IE7+，而伪类选择器:checked和label:for属性兼容IE9+（又是这一道坎…）。 IE7、8的兼容由选择器的妙用，让我想到了属性选择器[checked]，兼容性为IE7+。 .ie8 [checked]+.check-icons .icon-check,.ie7 [checked]+.check-icons .icon-check &#123; display: inline-block;&#125;.ie8 [checked]+.check-icons .icon-uncheck,.ie7 [checked]+.check-icons .icon-uncheck &#123; display: none;&#125; 我针对IE7、8应用了这些样式，for属性失去了作用，就需要绑定点击事件来更改checked值。做完之后发现并没有什么卵用。 因为属性选择器是针对标签字面量属性启作用，而如input.checked = true;这种修改方式是不会影响到标签上定义的属性。 这就牵扯到了attribute和property的区别。 var ck = document.createElement('input');ck.type = 'checkbox';document.body.appendChild(ck);ck.checked = true;ck.getAttribute('checked'); // nullck.checked = false;ck.setAttribute('checked','checked');ck.checked // false attribute 是 html 标签的属性 property 是 Dom 标准属性 也许是因为标签自定义属性的存在，这两个属性值是不同步的。 如果想要使[checked]选择器生效，势必要在点击事件中同步修改attribute和property。 实验后发现在IE7、8下正确运行了，对应的icon的display属性确实变化了，但是肉眼看不到样式更改。不知道是不是渲染能力差的原因，总是需要在控制台里点击对应的标签后才看得到更改后的样式。 思前思后，既然总归是需要用 js 去兼容，那在IE7、8下还是使用切换class来控制样式。","tags":[{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"iconfont","slug":"iconfont","permalink":"http://imys.net/tags/iconfont/"},{"name":"radio","slug":"radio","permalink":"http://imys.net/tags/radio/"},{"name":"checkbox","slug":"checkbox","permalink":"http://imys.net/tags/checkbox/"}]},{"title":"移动端页面开发关键—尺寸和布局","date":"2015-11-07T15:02:29.000Z","path":"20151107/mobile-page-size-and-layout.html","text":"早上去公司加了半天班（带薪的），为APP上线做了个专题介绍页。当然现在的主题不是介绍在这个专题中我用了哪些技术、实现了何种酷炫的特效。实际上我为了赶时间，我破天荒的没有贯彻自己的一贯作风—造轮子，而是直接引了一个第三方库。在这个APP开发中，我负责内嵌网页的开发，这也是我第一次涉足一个完整的移动端开发项目，以往只写过一些活动分享页、专题页。 对于页面兼容性影响最大的两个因素就是“尺寸”和“布局”。好在之前通过社区、博客等看过此类文章，已有了足够的认识，这次项目“实践”的成分更多。 尺寸在移动端页面，我用到的尺寸单位有em、rem、vw。px基本不用，但我会设置Dom根元素html字体大小为14px，一来方便em和rem的尺寸计算，二来14px是最常用的字体大小。 常规浏览器默认字体大小为16px，最小字体为12px。 em首先你要有这样一个基础的认知： 假如一个元素没有重设字体大小，那么它的字体大小会继承父级元素，如果父级也没有设置大小，那么依次类推一直追溯到body、html。 em是相对于当前元素字体大小计算像素值的，计算方法是em值 * 字体大小。 举例：一个元素设置了高度为2em，那么实际像素值为2 * 14px = 28px，而一旦这个元素重设了字体大小为2em，那么该元素高度值为2 * 28px = 56px。另外，其后的子元素的计算基数都会改变。 使用em时一旦有设置字体大小的样式出现就需要注意重新计算一些属性值大小了。 rem与 em 相比，这货看起来多了一个字母，显然是属于升级版本。rem是始终相对与 Dom 根元素html来计算像素值的。不管当前元素字体如何设置，计算时字体大小仍然以html的字体设置为基准。 vwvw指的的当前屏幕宽度，与之对应的还有 vh，表示屏幕高度。如果屏幕宽为 360px，那么 100vw = 360px。 是否感觉并没有什么卵用？别着急，下面说一下我的一次适用经历。 html： &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;cont cont-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; css： .box { width: 100%; overflow: hidden; } .inner { width: 300%; } .cont { float: left; width: 100%; } 以上代码用以实现三屏的左右切换效果，外层容器.box和三个内容块宽度为屏幕宽度，三个内容块设置了左浮动样式。此时，内层容器.inner需要有3倍的屏幕宽度以承载三个内容块。但是由于宽度继承的关系，在内层容器.inner宽度改变后，内容块的宽度计算基数也改变了。此时设置的100%是等于父级元素宽度的，也就是三倍屏宽。 使用js是很容易解决这个问题的，不过vw显然是可以适用这个场景的。只需要如下设置便可解决问题。 .cont { width: 100vw; } 该属性在兼容性为android 4.4+，谨慎使用。 devicePixelRatio在一个图表页中，我用canvas画了个饼图。发现在手机屏幕中区块颜色显得模糊。于是搜索资料就找到了这个属性，window.devicePixelRatio。目前我对这个属性的理解还不深，基本的理解为：屏幕缩放比。传送门：张鑫旭：设备像素比devicePixelRatio简单介绍 我们通过写的css中像素仅为逻辑像素，就是你看到的宽度，而实际上手机屏幕单个点是可能存在多个像素的。 如果是常规页面元素是用不到这个属性的，而canvas的真实宽度和css宽度是不一致的。计算方法为：canvas.width = canvas.style.width * devicePixelRatio。 需要注意：一旦重设了canvas的真实宽度，那么canvas之上的一切元素都需要乘以devicePixelRatio进行缩放。 布局在PC上为了兼容可恶的IE不得不使用大量的浮动来进行块级元素的并行排行。而在移动端我们有了更好的选择，但不是inline-block，而是flex。 使用flex可以轻易的实现等宽、散列、垂直居中、多行排列、底部对齐等等各种布局。 定义一个flex容器 .flex-row { display: flex; } 通过设置容器属性，可以呈现不同的排列对齐方式。 flex-wrap定义容器换行方式，默认不换行。可设置换行和反向换行。 flex-direction排列方向，默认子元素从左到右顺序排列。通过设置该值可以实现反向排列或垂直方向的上下排列。 justify-content主轴（水平方向）对齐方式，默认左对齐。可以实现居中、右对齐、等宽间隔等排列。 align-items侧轴（垂直）对齐方式。可实现垂直居中、底部对齐、基线对齐等。 align-content多轴垂直对齐方式。 最后附上Demo：flex常用布局 参考： 大漠：Flexbox——快速布局神器 阮一峰：Flex 布局教程：语法篇 阮一峰：Flex 布局教程：实例篇","tags":[{"name":"devicePixelRatio","slug":"devicePixelRatio","permalink":"http://imys.net/tags/devicePixelRatio/"},{"name":"em","slug":"em","permalink":"http://imys.net/tags/em/"},{"name":"移动端","slug":"移动端","permalink":"http://imys.net/tags/移动端/"},{"name":"rem","slug":"rem","permalink":"http://imys.net/tags/rem/"},{"name":"vw","slug":"vw","permalink":"http://imys.net/tags/vw/"},{"name":"flex","slug":"flex","permalink":"http://imys.net/tags/flex/"}]},{"title":"实现一个简单的模块加载器","date":"2015-10-23T12:41:39.000Z","path":"20151023/simple-module-loader.html","text":"最近大半年也写了不少通用模块，却从来没使用过一种通过书写格式。目前公司的前端通用库还是jQuery, 但也不是所有的模块都适合以jQuery 插件的形式开发。平时写的时候一般以立即执行函数或 OO 形式开发，以目前项目情况来看也不是很需要用require.js或sea.js之类的加载器。 其实我的需求很简单，就是抹去模块在全局作用域的定义，以通用的形式定义和引用。 最终目标从结果出发分析需求，先列出来最终想要的代码形式。 // 形式1：匿名模块，只有一个注入exports参数的函数体module(function (exports) &#123; console.log(require('m1').msg);&#125;);// 形式2：具名模块，包含一个模块名称参数和一个注入exports参数的函数体module('m1', function (exports) &#123; exports.msg = 'hello';&#125;);// 形式3：具名模块，包含一个模块名称参数、依赖模块数组、和一个注入依赖模块、exports参数的函数体module('m2', ['m1'], function (m1, exports) &#123; exports.msg = m1.msg + \"World\";&#125;);// 形式4：匿名模块，与形式3相比没有模块名称module(['m2'], function (m2, exports) &#123; console.log(m2.msg);&#125;); 使用module定义一个模块，拥有一个函数上下文，可以定义模块名称和引用其他模块，也可以通过注入的exports参数输出模块开放接口。某些时候也许需要require(&#39;模块名&#39;)这种形式来直接引用模块。 1. 注入环境变量从以上四种模块形式来看，module和require两个变量的作用域是全局，需要注入到window中。 (function(w, f)&#123; w.module = function () &#123; &#125; w.require = function (namne) &#123; &#125; &#125;(window, undefined)); 一个简单的立即执行函数就可以做到。 2. 解析 module 参数module参数的数量是不固定的，最少1个（形式1）、最多3个（形式3）。可以需要通过判断参数数量和类型加以区分。 w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125;&#125; 参数数量不固定，也就不必定义形参了，直接从arguments中获取。 arguments[0]是模块名，模块名存在时永远是参数第一位；arguments[1]是引用模块，模块名不存在时arguments[0]为引用模块，所以判断模块名是数组类型时重新赋值；不管何种形式模块函数都是最后一个参数，直接使用arguments[arguments.length - 1]获取； 3. 实现 module模块函数的参数数量也是不固定的，但至少需要注入exports来输出开放接口。每多引用一个模块，就需要向模块函数中注入一个对应参数。 var modules = &#123;&#125;; // 模块容器w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125; // 1. 取出模块 var args = []; if(mods instanceof Array) &#123; for(var i = 0; i &lt; mods.length; i++) &#123; args.push(modules[mods[i]]); &#125; &#125; // 2. 注册模块 if(typeof modName === 'string') &#123; modules[modName] = &#123;&#125;; args.push(modules[modName]); &#125; // 3. 注入参数，执行模块 context.apply(this, args);&#125; 遍历mods取出模块：定义了一个变量modules存放模块，那么假如一个模块引用了模块a、b，则mods = [&#39;a&#39;, &#39;b&#39;];，a、b两个模块的真值即为modules[&#39;a&#39;]、modules[&#39;b&#39;]。当模块为形式2时，参数有两个，参数2为模块函数。此时 arguments[1] === arguments[arguments.length - 1]，引用模块(mods)也指向了模块函数，所以要判断mods类型。注册模块：每一个具名模块都需要注册到modules中，以备其他模块引用。当模块为匿名模块时，不需要注册，所以要判断modName类型。注入参数，执行模块：对于不定数量的参数注入，显然是使用apply最简单。 4. 实现 requirevar modules = &#123;&#125;; // 模块容器w.module = function () &#123; //...&#125;w.require = function (namne) &#123; return modules[namne];&#125; 暂时不考虑异步加载、加载路径解析等各种情况了，直接从容器中取到模块… 5. 完整代码(function(w, f)&#123; var modules = &#123;&#125;; // 模块容器 w.module = function () &#123; var modName = arguments[0], // 模块名 String mods = arguments[1], // 引用模块 Array context = arguments[arguments.length - 1]; // 模块函数 Function if(modName instanceof Array) &#123; mods = modName; modName = f; &#125; var args = []; if(mods instanceof Array) &#123; for(var i = 0; i &lt; mods.length; i++) &#123; args.push(modules[mods[i]]); &#125; &#125; if(typeof modName === 'string') &#123; modules[modName] = &#123;&#125;; args.push(modules[modName]); &#125; context.apply(this, args); &#125; w.require = function (namne) &#123; return modules[namne]; &#125; &#125;(window, undefined));// 形式1：匿名模块，只有一个注入exports参数的函数体module(function (exports) &#123; console.log(require('m1').msg);&#125;);// 形式2：具名模块，包含一个模块名称参数和一个注入exports参数的函数体module('m1', function (exports) &#123; exports.msg = 'hello';&#125;);// 形式3：具名模块，包含一个模块名称参数、依赖模块数组、和一个注入依赖模块、exports参数的函数体module('m2', ['m1'], function (m1, exports) &#123; exports.msg = m1.msg + \"World\";&#125;);// 形式4：匿名模块，与形式3相比没有模块名称module(['m2'], function (m2, exports) &#123; console.log(m2.msg);&#125;); 执行以上代码会报错，代码是自上而下同步执行的，形式1运行阶段模块m1还未定义。把形式1放到形式4之后执行，输出： helloWorldhello","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"}]},{"title":"gulp改善工作流记录","date":"2015-10-22T02:37:53.000Z","path":"20151022/use-gulp-front-building-exp.html","text":"上个月向领导提出的使用gulp+ejs模块化html最近得到了实施，大概记录下此次改造工作。 目录结构html -dest --Folder --index.html --... -src --Folder --Modules ---header.html ---... --index.html --... static -dest --css --js --img -src --css --js --img --less node_modules gulpfile.js package.json gulp模块var gulp = require(&apos;gulp&apos;), less = require(&apos;gulp-less&apos;), minifycss = require(&apos;gulp-minify-css&apos;), jshint = require(&apos;gulp-jshint&apos;), uglify = require(&apos;gulp-uglify&apos;), imagemin = require(&apos;gulp-imagemin&apos;), pngquant = require(&apos;imagemin-pngquant&apos;), rename = require(&apos;gulp-rename&apos;), notify = require(&apos;gulp-notify&apos;), browserSync = require(&apos;browser-sync&apos;), ejs = require(&apos;gulp-ejs&apos;), changed = require(&apos;gulp-changed&apos;), replace = require(&apos;gulp-replace&apos;); html选择了ejs来管理，css预处理选择了less。简单、实用！ 对于浏览器同步工具，本来使用的是live-reload，在初次使用中感觉不是很顺畅，之后换成了browserSync。browserSync 除了文件更改实时刷新浏览器外，还有多设备同步功能，通过可视化控制台可以实时测试移动端代码。对比而言，live-reload 依赖 Chrome 及 LiveReload 插件，应该是借助 Chrome 的某种开放接口实现的。而 browserSync 是基于虚拟服务器的，所有可以实现多设备的控制。 工作流编写html、less、js =&gt; 浏览器访问（URL对应html文件目录） =&gt; 浏览器显示编译后的html、css、js =&gt; html已经过模板合并，include等关键字是没有的 =&gt; css是less编译生成的，页面从始至终引用的都是 css 文件，不过会有一个对应的同名 less 文件。 改造进行阶段也没遇到什么太大问题，能遇到的问题也都能在github中找到答案。不过还是要根据各自团队的项目情况因地制宜，合理配置。","tags":[{"name":"gulp","slug":"gulp","permalink":"http://imys.net/tags/gulp/"},{"name":"前端构建","slug":"前端构建","permalink":"http://imys.net/tags/前端构建/"}]},{"title":"Node.js命令行玩法","date":"2015-09-19T12:20:13.000Z","path":"20150919/nodejs-shell.html","text":"Node.js 的热门之处就在于其命令行开发能力。一个在 shell 下编码的程序员绝对要比在常规编辑器上编码的程序员酷！ 基础环境 win10 x64 node.js npm hello world一切从 hello world 开始！ #!/usr/bin/env nodeconsole.log('hello world'); 普通的 node.js 脚本需要使用node 文件名的形式执行，在脚本首行加上#!/usr/bin/env node可以在linux环境中指定脚本的解释程序。 &gt; hello.jshello world 全局命令以上的做法只能在特定的目录下执行该脚本文件，如果想做到如node般的无处不在，需要借用npm了。 在当前目录新建package.json，如下编码： &#123; \"name\": \"hello\", \"bin\": &#123; \"hello\": \"hello.js\" &#125;&#125; 然后执行npm link命令，将会把以上配置注册到全局，这样在任何一个目录都可以调用hello输出hello world了。 命令行参数光有特定命令名也只能执行一项特定任务，现在该实现多态了。 写一个小工具吧。需求很简单，执行run name打开对应的应用程序。 新建文件config.json、run.js，config.json用于配置应用程序的路径。 &#123; \"qq\": \"D:\\\\qq\\\\Bin\\\\QQ.exe\"&#125; 先拿企鹅开刀，在config.json文件中配置qq.exe的绝对路径。另外别忘了在package.json中添加run.js。 #!/usr/bin/env nodevar name = process.argv[2], exec = require('child_process').exec, fs = require('fs');var cfg = JSON.parse(fs.readFileSync(__dirname + '/config.json'));var child = exec('start ' + cfg[name], function(err, stdout, stderr) &#123; if (err) throw err;&#125;); 使用系统变量process.argv获取输入参数，引用fs模块用于读取配置文件，child_process模块用于执行系统命令。 可为什么参数索引是 2 呢？难道命令行索引从 1 开始吗？ 其实是因为我们实际执行的命令还是node run name，node索引为 0。 开始测试。 run qq 企鹅登录窗口应声而出。如果还需要其他应用程序的命令行启动可以在config.json中添加新的配置项。 以上代码使用的是 node.js 原生的命令行模块，还有一些更方便的包装模块，参考：阮一峰 - Node.js 命令行程序开发教程。","tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://imys.net/tags/Nodejs/"},{"name":"cmd","slug":"cmd","permalink":"http://imys.net/tags/cmd/"}]},{"title":"html5调用手机相机并压缩、上传","date":"2015-09-16T08:21:28.000Z","path":"20150916/webapp-input-use-camera.html","text":"近日刚做的一个功能，要在app里使用内嵌页面进行图像的上传。从功能上看，原生的实现应该是最好的。毕竟页面上所有的东西都隔着一个浏览器，所有的实现都要依赖浏览器提供的接口，不同的浏览器对接口的实现又有差异……到最后又会陷入兼容性的大坑!吐槽归吐槽，但是折腾的劲头不能丢！ 使用input file[camera]属性调用相机简直So easy！ &lt;input type=\"file\" accept=\"image/*;\" capture=\"camera\" &gt; 只需要这么一条简单的代码，在手机浏览器点击就可以打开相机了。 capture是什么？其实就是对打开方式的设置。 &lt;!-- capture=camcorder，调用手机摄像功能 --&gt;&lt;input type=\"file\" accept=\"video/*\" capture=\"camcorder\" &gt; &lt;!-- capture=microphone，调用手机录音功能 --&gt;&lt;input type=\"file\" accept=\"audio/*\" capture=\"microphone\" &gt; 魅族MX5测试结果： 谷歌浏览器可以打开相机和摄像功能，其他方式均为相机、图库、文件管理器等混合选择项。 自带浏览器打开均为文件管理器。 由此说明此属性兼容性还是个问题。不过这并不能阻止我继续折腾下去！ 图片压缩在如今这个手机普遍千万像素的时代，一张照片动辄5M的大小。作为一个良心的开发者，我们是要为用户的流量负责的。该怎么做？我也不知道。大家都在用canvas实现，我也就用了。 document.getElementById('file').addEventListener('change', function() &#123; var reader = new FileReader(); reader.onload = function (e) &#123; compress(this.result); &#125;; reader.readAsDataURL(this.files[0]);&#125;, false); 不管文件域是用何种方式打开的，都可以在 change 事件中获取到选择的文件或拍摄的照片。 创建一个FileReader对象，我们需要调用readAsDataURL把文件转换为base64图像编码，如data:image/jpeg;base64……这种格式。onload是一个异步回调，当文件读取完执行该方法内代码。this.result记录读取结果，如果读取失败，该值为null。在这里进行图片压缩的具体操作。 var compress = function (res) &#123; var img = new Image(), maxH = 160; img.onload = function () &#123; var cvs = document.createElement('canvas'), ctx = cvs.getContext('2d'); if(img.height &gt; maxH) &#123; img.width *= maxH / img.height; img.height = maxH; &#125; cvs.width = img.width; cvs.height = img.height; ctx.clearRect(0, 0, cvs.width, cvs.height); ctx.drawImage(img, 0, 0, img.width, img.height); var dataUrl = cvs.toDataURL('image/jpeg', 0.6); // 上传略 &#125; img.src = res;&#125; 创建一个Image对象，给src属性赋值为读取结果，同样在onload异步回调中编写处理图片的代码。这里就要开始使用canvas进行图片压缩了。 首先是尺寸按比例缩放，然后把图片绘到画布上，最后调用toDataURL方法压缩图像质量。 context.toDataURL('MIME类型', 图像质量0-1); // 该方法返回base64图像编码 代码里省略了一些校监操作，如文件类型约束和文件大小判断（小于一定值可以不压缩）。最后就是把数据发送到后端的操作，这里就不说了。 Html5调用摄像头通过以上的代码已经可以实现调用手机相机拍照、压缩、上传这一整套流程了。不过在折腾的过程中也发现了一种调用摄像头的方法。注意，是摄像头！使用input调用的是相机。其中的差别就是摄像头是只捕获画面，相机还包括原生的一些拍照、设置等控件。 通过对摄像头的调用可以做很多有趣的事，比如拍照美化、滤镜等。可以说实现一个第三方相机是没问题的。之前下载过一款安卓相机APP，不到100K的大小，可以实现拍照的一些风格化，也许就是Html5实现的呢。 需要用到的是 getUserMedia API，具体的实现这里就不贴了。","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"webapp","slug":"webapp","permalink":"http://imys.net/tags/webapp/"},{"name":"file","slug":"file","permalink":"http://imys.net/tags/file/"}]},{"title":"使用gulp+ejs模块化html","date":"2015-09-08T10:04:47.000Z","path":"20150908/gulp-ejs-module.html","text":"在静态页面目录中，同子目录下的页面往往有很多通用的模块。平常的编码一般是通用的代码直接复制到各个页面，样式写成公用，然后在各个需要的页面引用。而一个产品在实地运行中往往要经历无数次的迭代，于是页面文档结构和样式也在不断的变化。独立性的页面比较轻松，一个页面修改就好了，而一些公用的页面模块往往需要在各个页面逐个修改。这显然是一种极其枯燥的重复性动作！ 在此之前我用 C# 写了一个文件批量替换的工具，用于批量替换某个目录下的某个模块代码。虽然效率提高了一些，但是从方法学角度看绝对不是最好的。 很久之前就想过使用前端模块拼装 html。以 ejs 为例，则需要在页面中引入模版解析文件 ejs.js，页面中还需要写一些 ejs 相关的配置代码。而这些东西对于后端套用页面来说是无用的，可能还会造成一些混乱。还有一种引用方式是使用 nodeJs 调用 ejs 去解析模版文件，这样在预览静态页面时则需要建立 node 服务器。而当前团队中并不是每个人都装有 node 环境。 最近工作闲暇了又想到这个问题，其实要解决的最根本问题就是： 模块化开发页面，开发完成后可以一条指令合并成可直接预览的静态页面。 我早该想到 gulp 了，既然 gulp 是一个基于流的前端构建工具，那么对于这个问题应该是可以解决的。 起初我是这样想的： 模板中使用相对路径标记模块引用 读取文件把这些标记还原为路径 读取这些路径的文件内容插入到模板中 生成到对应目标目录 这样做等于实现了一套模版解析合并的过程，并不困难。 在探索的过程中，我发现了一个基于 gulp 和 ejs 的插件 gulp-ejs，并按照示例实验后达成了我的想法。随后新的问题便来了。 每个页面有着不同标题和样式、脚本引用，虽然可以在执行 gulp 任务时指定参数，但是不可能每个页面的参数配置都一样。难道要为每个页面编写一个任务？你会甘心用这么傻的办法吗？从设计模式角度讲，这个任务应该是唯一的，但是可以根据一些参数配置达到多态！ 之后我改造了 gulp-ejs： 在模板文件同级目录下添加同名的 .json 配置文件 在其对模板渲染时获取模板路径，再转换后缀为 json，这样就匹配到了对应的配置文件 解析 json 文件为 json 对象，作为参数传入 ejs 中，这样模版内就可以访问配置文件的数据了 之后便可以根据配置文件随心所欲的插入当前页面的特定项目 这样标题、样式、脚本，神马都解决了！ 就在刚才我又想到了另外一个主意。 如果你觉得每个模板对应一个 json 文件麻烦的话，可以只建立一个配置文件。假如你有 index 、product 、service 三个模版，那么你的配置文件可以这样写： &#123; \"index\": &#123; \"title\": \"首页\" &#125;, \"product\": &#123; \"title\": \"产品页\" &#125;, \"service\": &#123; \"title\": \"服务页\" &#125;&#125; 那么在 index 模版中输出 title，就可以写成 &lt;%=index.title %&gt; 这种格式。长久下去配置文件一定会越来越大，而且每个模版中都被注入了整站的配置项，真的好吗？ 为了使每个页面只注入当前页面的数据，可以在模版渲染前拿到模版名称，如 index ； 向 ejs 传入的数据就变成了 config[&quot;index&quot;]； 这样在每个模版中依然可以直接用 &lt;%=title %&gt; 这种格式调用了 不管采取哪种办法，最终的结果是一致的。哪怕是每个模版注入整站配置的做法，也只是在 gulp 任务阶段执行效率低点，并不会上升到影响性能的高度。不过，我还是倾向于一个页面对应一个配置文件的办法，谁让我是处女座。 以下是对该方案的简单描述。 目录结构├ templates 模版 ├──── _partial 模块 ├──────── header.ejs ├──────── footer.ejs ├──────── nav.ejs ├──────── left.ejs ├──────── right.ejs ├──── index.ejs 布局页 ├──── index.json 布局页配置文件 ├ html 页面 ├──── index.html 生成的静态页面 ├ node_modules node模块 ├ gulpfile.js gulp 工作流程 模板编码，即 templates/ 目录，一个布局页对应一个同名静态页面，按需引入或编写新的页面模块。在这个阶段可以使用express建立node服务器进行实时页面预览。 编写配置文件，使用通用的 json 格式，一个页面对应一个同名的配置文件。目前预想的配置信息有： title：页面标题 、styles：依赖的样式文件路径、 scripts：依赖的脚本文件路径 ，随时可以根据实际情况添加新的配置。 执行 gulp 任务，生成页面到 html/ 目录。 未模块化页面的处理之前未模块化的静态页面，保持原样即可，因为在这个流程中与之前的页面是没有任何冲突关系的。一些频繁修改的页面，可以按需抽取出模块，进行页面分割。 完整Demo https://github.com/yscoder/gulp-ejs-demo 写在最后可能我所做的这些对于国内一些优秀的前端团队来说很土，但是适合的才是最好的！目前我所在的公司前端的职能还仅限于页面编码、交互实现和一些通用插件开发，起点真的很低。不过，这也让我有了更多的机会去改革和实践新技术。","tags":[{"name":"gulp","slug":"gulp","permalink":"http://imys.net/tags/gulp/"},{"name":"ejs","slug":"ejs","permalink":"http://imys.net/tags/ejs/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"}]},{"title":"前端文字的截断处理","date":"2015-09-06T09:37:32.000Z","path":"20150906/text-truncation.html","text":"关于前端页面的文字溢出截断的招数已经很常见了。通常的实现有，前端css控制、后端字数输出控制或者前端js字数处理等。 单行文字单行文字的溢出处理很简单，我通常是使用css来控制，在文字末尾加上...。 .ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; 给需要文字截断的节点增加一个这样的基础类，然后设置该节点的宽。同时注意给未来可能会出现溢出的节点也加上此类，再设置最大宽度max-width，因为很多奇葩用户的输入是你无法掌控的。 - -！ 多行文字我希望在一个的固定高度的容器中，内容超出后，最后一个文字显示...。 如法炮制给多行文字的容器添加ellipsis类后，你会发现的确是显示...，不过此时文字是一行的。因为在该类中添加了属性white-space，用来定义一个段落如何换行。属性值nowrap：禁止文本换行，除非遇到&lt;br&gt;。 一番思考后，确定了一个方案。 给固定高度的容器添加overflow: hidden； 给容器添加相对定位； 添加伪元素样式，content:&#39;...&#39;，绝对定位，然后位置定位在容器末尾。 伪元素的兼容性为IE8，如果需要兼容IE7的可以使用标签代替。 带显示全部的多行文字类似 QQ 空间、微信、微博那种。 使用 2 个伪元素加 1 个 a 链接实现。精妙之处在于使用伪元素遮挡一行文字，让 a 链接位于伪元素之上显示。 更新于 2016-6-27。","tags":[{"name":"html","slug":"html","permalink":"http://imys.net/tags/html/"},{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"ellipsis","slug":"ellipsis","permalink":"http://imys.net/tags/ellipsis/"}]},{"title":"html5上传进度实现","date":"2015-09-02T08:26:13.000Z","path":"20150902/h5-upload-progress.html","text":"博客一个月没更新了，着实是有点忙。目前公司新版上线也到最后一波了，部分人员转战了一个新的APP产品的开发。主体还是原生APP，也会有部分页面需要嵌入WEB页面，我也有幸作为唯一的前端人员加入了。 不过这次讲的内容跟这个APP没有半毛钱关系，是公司内部工作系统的一个扫码上传功能。好吧，我参与的确实有点多！ 要实现实时的进度展示，需要以下几个关键： 异步上传 文件总大小 文件已上传大小 基本HTML结构&lt;input type=\"file\" id=\"upload\" accept=\"image/*\" &gt; 异步上传XHR是必须的，此外还需要一个FormData对象。 FormData，译为表单数据，也就是一个保存表单数据的容器。可以利用这个对象写入键值对的数据项，再用xhr发送到处理接口。 var data = new FormData();data.append('id', 9527);data.append('name', '张三');data.append('sex', '男'); 不仅可以像以上简单的添加值类型，文件类型也不例外。这样就可以直接使用xhr的send方法发送到后端。 document.querySelector('#upload').addEventListener('change', function() &#123; var file = this.files[0], data = new FormData(); data.append('photo', file); var xhr = new XMLHttpRequest(); xhr.addEventListener('load', function(event)&#123; // Success or Error &#125;, false); xhr.open('post', '/doLoad'); xhr.send(data); &#125;); 上传进度与FormData相对应的上传状态监听事件 xhr.upload.addEventListener('progress', function(event)&#123; // do...&#125;, false); 该事件可以通过event对象获取上传状态。 event.loaded: 已上传大小 event.total: 文件总大小 这样计算进度就不在话下了，具体实现也就不废话了，众大侠各展神通吧！","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"文件上传","slug":"文件上传","permalink":"http://imys.net/tags/文件上传/"}]},{"title":"require.js入门--用面向对象语言来理解js模块化","date":"2015-08-07T02:33:25.000Z","path":"20150807/js-module-requirejs.html","text":"作为一个曾经的后端开发者，当我第一眼看到一些javascript模块化的代码案例时，我就想到了java、c#这些天生的模块化语言。今天就拿 require.js 来捋一捋这其中的异同。 模块化一个基本的javascript模块，应该是隐藏私有成员及方法，暴漏外部调用的所需的接口。常见的写法有： var module = (function()&#123; var prop = ''; var tool = function(p)&#123; &#125;; //... return &#123; fn: function()&#123; tool(prop); &#125; &#125;;&#125;)(); 在以上代码中，外部环境无法读取和修改变量prop和方法tool，但是该模块返回了一个公开的对象，并有一个可执行的方法fn。 这不就相当于面向对象编程中的封装吗？在以上代码中使用了闭包来隔离变量作用域，而像java中可以使用public、private这样的关键字来定义成员。 require.js入门刚才通过一段简单的代码理解了模块化的作用，下面来看看require.js是如何定义和调用模块的。 页面加载&lt;script data-main=\"main\" src=\"http://cdn.bootcss.com/require.js/2.1.20/require.min.js\"&gt;&lt;/script&gt; 在页面中插入了require.js文件，使用data-main指定主模块或者叫入口模块，我理解为java中的main()方法。data-main属性可以写模块文件的路径，在require.js中默认的后缀.js可省略。 入口模块如果我们的页面非常简单的话，在入口模块中可以写我们的js代码。比如： console.log('Hello require.js!'); 此时刷新页面就会直接在控制台输出Hello require.js!。当然如果是这样的话，也就没必要用require.js了。 正常的写法一般是这样的： require(['module1', 'module2'], function (module1, module2)&#123; //...&#125;); 第一个参数数组表示依赖的模块名，然后在其后的回调函数中就可以使用这些模块。 加载模块当然，不可能凭空使用模块，按照常规肯定需要某个地方指定模块加载路径吧。 在主模块头部可作以下配置： require.config(&#123; paths: &#123; 'module1': 'js/module1', 'module2': 'js/module2' &#125;&#125;); 如果所有模块都在同一个目录则可以配置baseUrl。 require.config(&#123; baseUrl: 'js', paths: &#123; 'module1': 'module1', 'module2': 'module2' &#125;&#125;); 也可以直接使用URL配置远程文件链接。 require.config(&#123; paths: &#123; 'jquery': 'http://cdn.bootcss.com/jquery/2.1.4/jquery' &#125;&#125;); 与java中的导包的作用类似，import xxx.xxx.xxx;。 定义模块目前常见的的js模块规范有CMD、AMD、CommonJS以及兼容性写法的UMD，require.js是实现了AMD规范的js库。 定义一个模块tool，如下写法： define(function ()&#123; var msg = 'The Hello at tool.'; return &#123; hello: function()&#123; console.log(msg); &#125; &#125;;&#125;); 如果该模块依赖其他模块，如jquery，就需要定义模块依赖。如入口模块的定义一样，第一个参数写成模块名数组。 define('[jquery]', function ($)&#123; var msg = 'The Hello at tool.'; return &#123; hello: function()&#123; console.log(msg); console.log($ === undefined); &#125; &#125;;&#125;); 依赖的模块依然需要在入口模块中配置加载路径，但不是必须要在入口模块中注入。 在这个模块中我们发现了这段代码与一开始的基本模块写法类似，一样是只暴漏必须的调用接口。 现在可以在入口模块中调用这个模块： require(['tool'], function (t)&#123; t.hello();&#125;); 如果jquery加载正确的话，控制台会输出： The Hello at tool.false 好了，现在可以去更新简历在技能上加上require.js了！ 结束各种模块化规范殊途同归，都是为了解决同样的问题。理解了其中一种，都可以轻松掌握其他规范的写法。未来我们还有天然支持类和模块的ES6，期待吧？ 我一直认为好的开发人员不应该局限于一个技术栈，因为这样会阻碍你对一个问题的全面认知和对新知识的快速领会。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"},{"name":"模块化","slug":"模块化","permalink":"http://imys.net/tags/模块化/"},{"name":"require.js","slug":"require-js","permalink":"http://imys.net/tags/require-js/"}]},{"title":"canvas实践--图表组件仪表盘、雷达图","date":"2015-07-31T01:14:34.000Z","path":"20150731/canvas-chart-demo.html","text":"大数据概念的到来，图表的运用越来越广泛，不搞搞数据，都不好意思说是互联网公司。 最近公司又有一块图表展示的栏目要做，由于之前的图表栏目都是我完成的，这次不出意料又落在我身上。之前的图表展示我用的是echarts，按格式封装数据调用就行了。这次领导突然对图表样式有了一些要求，虽然echarts的配置够OP，也不可能完完全全跟设计图搞成一样的。 暨于上次的canvas的使用，我决定自己动手实现所需要的图表组件。这是最终的完成样式： 首先根据效果图来划分出各个图层，以及图层层级位置。然后按照层级关系由下向上依次绘制。 整个编码过程还是很顺利的，一些问题都得到了很好的解决。 查看github 踩过的坎确定圆上任意一点的位置此次绘制的图表分别是仪表盘和雷达图，很多图形或点的位置都需要进行一定的计算。比如仪表盘上的指针坐标、雷达图各个角的位置等。而两个图表都是基于圆心角绘制的图形，所以可以使用 圆的参数方程 来轻松解决。 x = cx + r &times; cos(π &times; e)y = cy + r &times; sin(π &times; e) cx: 圆心点横坐标 r: 半径 e: 结束角 cy: 圆心点纵坐标 绘制渐变色圆环原本看到仪表盘样式图时，预想的这个渐变圆环需要一节一节用不同的颜色画上去的。实际的实现要简单太多了！可以直接使用绘制渐变色的方法。canvas支持线性渐变和放射形渐变，这里使用的是线性渐变。 方法 描述 createLinearGradient(x0, y0, x1, y1) 创建线性渐变，参数分别表示起始点x坐标和y坐标、结束点x坐标和y坐标。 addColorStop(stop, color) 规定渐变对象中的颜色和停止位置，stop表示一个颜色的渐变结束位置0-1之间，color表示渐变色。 具体的使用可以点这里。 顺便说说如何根据设计图确定渐变的位置和颜色。 用ps打开美工给的psd文件； 找到渐变的图层样式设置； 照着上面的设置来就行了。 绘制虚线HTML5规范中已有绘制虚线的方法，支持的浏览器有Chrome, Safari, IE 11 和 Opera。 context.setLineDash() 使用参考 开场动画canvas本身没有这方面的支持，需要使用定时器来进行一定时间的重绘来实现。 整个逻辑大概是这样的： // 1. 设置最小初始值，获取最终值var value = 0, endValue = 668; // 2. 启动定时器根据value动态绘制var timer = setInterval(function()&#123; // 3. value累加，如果小于最终值就加一定值，否则等于最终值 value = value + 1 &gt; endValue ? endValue : value + 1; // 4. 清空画布 context.clearRect(0, 0, 500, 300); // 5. 根据value来进行此次绘制 // 具体步骤省略... // 6. 判断value是否等于最终值来结束定时器 if(value === endValue) &#123; clearInterval(timer); &#125; &#125;, 10); 可以通过调整累加数和定时器时间来控制动画速度。 其他说起来这两个组件的封装和调用也是凭着echarts的使用经验来设定的，感谢百度前端大大们为此作出的贡献！","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"http://imys.net/tags/canvas/"},{"name":"chart","slug":"chart","permalink":"http://imys.net/tags/chart/"}]},{"title":"Canvas初试--环形进度条的实现","date":"2015-07-22T00:21:53.000Z","path":"20150722/canvas-annulus-process.html","text":"起初想这么做既是css3不易实现圆环，而且也有低版本兼容问题，也想借此机会学习下canvas(虽然最后还是难逃兼容性 &gt;_&lt; )。做的过程中发现canvas跟C#中gdi绘图的步骤其实是差不多的。 先大概看了下canvas的相关API，有个可以画弧的方法arc。 通过合理的参数设置就能实现各种角度的圆弧，或者满圆。 定义canvas&lt;canvas id=\"process\" width=\"200\" height=\"200\" data-process=\"85\"&gt;&lt;/canvas&gt; 在基本的HTML5文档中添加一个canvas，定义了id宽高以及一个自定义属性表示要显示的进度值。 画背景圆（灰色）首先了解下arc方法： context.arc(x,y,r,sAngle,eAngle,counterclockwise); 参数 描述 x 圆的中心的 x 坐标。 y 圆的中心的 y 坐标。 r 圆的半径。 sAngle 起始角，以弧度计（弧的圆形的三点钟位置是 0 度）。 eAngle 结束角，以弧度计。 counterclockwise 可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。 var c = document.getElementById('process');var process = c.getAttribute('data-process');var ctx = c.getContext('2d');// 画灰色的圆ctx.beginPath();ctx.arc(100, 100, 80, 0, Math.PI*2);ctx.closePath();ctx.fillStyle = '#F6F6F6';ctx.fill(); 以上代码中设置了圆心为100,100，正好的画布中心，圆半径为80，起始角度0表示3点钟方向，结束角度Math.PI*2其实是个满圆。下一步会说明起始角度和结束角度具体算法。 画进度环（橙色）// 画进度环ctx.beginPath();ctx.moveTo(100, 100); ctx.arc(100, 100, 80, Math.PI*1.5, Math.PI*(1.5+2*process/100));ctx.closePath();ctx.fillStyle = '#FF9600';ctx.fill(); 与上一步比较，多了一句ctx.moveTo(x,y);，意为把路径移动到画布中的指定点，如果没有这一步画出来的就不是弧了。起始角度和结束角度也发生了变化，要想真正理解这两个角度，看下图。 3点钟方向用0(0PI)表示，6点钟是0.5PI，9点钟1PI，12点钟1.5PI，这样转一周回到3点钟即为2PI。所以满圆可以用起始角度0(0PI)和结束角度2PI表示。 我们要画的圆环是需要从12点钟方向开始的，所以设置起始角度1.5PI。process在第一步中获取了要显示的进度85，即为85/100的圆，按原来3点钟开始，那么结束角度可以计算为Math.PI*2*85/100。因为起始角度的变更，结束角度也要进行相应的变化，各在原来的基础上加了1.5的基数。 起始角度 0 -&gt; Math.PI &times; 0 -&gt; Math.PI &times; (0+1.5) -&gt; Math.PI &times; 1.5 结束角度 Math.PI &times; 2 -&gt; Math.PI &times; 2 &times; 85/100 -&gt; Math.PI &times; 2 &times; process/100 -&gt; Math.PI &times; (1.5+2 &times; process/100) 画内填充圆（白色）// 画内填充圆ctx.beginPath();ctx.arc(100, 100, 60, 0, Math.PI*2);ctx.closePath();ctx.fillStyle = '#fff';ctx.fill(); 半径减少20，进行内圆填充。 填充显示文字（数字百分比）// 填充文字ctx.font = \"bold 20pt Microsoft YaHei\"; ctx.fillStyle = '#333';ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.moveTo(100, 100); ctx.fillText(process+'%', 100, 100); 完成！ 关于canvas在IE7、8下的兼容需要引用google的 excanvas.js ，并把画图的相关的代码放到window.onload下。不过这个文件有些大，40K+，压缩后17K。","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"http://imys.net/tags/canvas/"},{"name":"process","slug":"process","permalink":"http://imys.net/tags/process/"}]},{"title":"用户体验--WEB站点快捷键实现方案","date":"2015-07-16T07:06:58.000Z","path":"20150716/ue-shortcut-key.html","text":"今天一大早就被头儿派了任务，让我整理一份可用快捷键操作的可行性方案。不敢懈怠，遂出此文。 分析对于WEB站点的多数操作也就是鼠标点点罢了，多数普通用户都是不愿意记那么多东西的，所以首先要考虑用户可接受性。 可以从以下几个方向考虑快捷键： 通用、易用、习惯，常用功能使用，可快速接受，习惯性按键 方便、快捷，有效提升操作效率 专用，针对特殊功能、特殊人群和特殊需求 计划可用键从语义化来讲，专门的键做专业的事。增加用户便利的前提下不能滥用一些系统和浏览器规划好的按键，如常用的复制和粘贴。此类按键很多，这就导致可被我们利用的键很少。最好的当然是设置1个键，不过在多数人习惯了office、QQ等软件后也习惯了一些快捷键操作。所以可以从这些习惯中推导出一些可用键，2-3个组合键也未尝不可，还可以考虑双击。 单键：Esc,Enter,Tab,Delete,Home,方向键等。组合键：Ctrl+*,Ctrl+alt+*。 可入手项 全局或局部的Tab焦点切换，特别是表单； 任何搜索和提交的地方都应该绑定Enter键； 表单文本框点两下backspace全部删除； Esc取消输入焦点或取消操作； Home跳转个人中心或企业中心； Del删除选中的项； 主导航或重要栏目的访问键； 用户的自定义快捷键； 标签页切换； 一键注销登陆用户； 站内搜索; 一键返回顶部； 容我三思…… 实现在上述项都需要实施的前提下，整个实现必然是需要贯穿整站的。会有全局的按键绑定，也会有针对性的某个功能或页面的实现。 最后我的想法如下： 添加全局Hook模块，捕获按键并执行对应的操作。 全局性的绑定可以写到全局js文件中，特殊情况特殊对待。","tags":[{"name":"WEB","slug":"WEB","permalink":"http://imys.net/tags/WEB/"},{"name":"用户体验","slug":"用户体验","permalink":"http://imys.net/tags/用户体验/"},{"name":"快捷键","slug":"快捷键","permalink":"http://imys.net/tags/快捷键/"}]},{"title":"造个轮子-基于jquery的文字提示插件jtip","date":"2015-07-15T07:21:58.000Z","path":"20150715/jqplugin-jtip.html","text":"最近工作不是很忙，看到站里一些纯图标的按钮还是使用的默认的title属性作文字提示，就造了这个轮子。 jtip介绍目前功能 位置自动居中对齐； 支持上下两个方向的的显示； 宽度自适应（超出长度限制自动换行）； 自定义显示场景（常态、警告、错误）； 可设置位置偏移量。 兼容性IE7+(包括IE7)，等现代浏览器。 使用可用于任何具有title属性的DOM元素。 如： &lt;a href=&quot;&quot; title=&quot;your title&quot;&gt;text&lt;/a&gt; &lt;div title=&quot;your title&quot;&gt;&lt;/div&gt; 依赖文件 jtip.css jquery.js jtip.js 调用$(selector).jtip({ direction : &apos;top&apos;, // 显示方向，可选值 top、bottom className: &apos;jtip&apos;, // 可自定义CSS类名 type: &apos;&apos;, // 显示类型，可选值 &apos;&apos;(缺省为空)、warning、danger skewing: 0 // 位置偏移量 }); 源码已上传github，https://github.com/yscoder/jtip 。 遇到的问题1.获取DOM节点基于文档的位置 某些情况下jQuery.offset()在IE8下无法获取准确数值，可以使用原生DOM属性offsetLeft、offsetTop获取，IE7仍需使用jQuery.offset()获取。 2.IE7容器宽度自适应 单行内容设置display:inline；多行内容设置min-width和overflow:visible。","tags":[{"name":"jquery插件","slug":"jquery插件","permalink":"http://imys.net/tags/jquery插件/"}]},{"title":"ie不显示iconfont字体图标","date":"2015-07-09T02:12:33.000Z","path":"20150709/ie-nodisplay-iconfont.html","text":"昨天助理妹子收到客户的反馈，说浏览器不显示按钮了。经过远程查看，发现是iconfont(字体图标)不显示了。新版网站上线后整站使用iconfont替代了图片图标，一些小按钮都是直接使用的iconfont。查看过后一时半会也是找不到原因，只是在脑海中一遍一遍的咒骂万恶的IE(客户使用的是IE8)！因为接触不到真实客户环境的关系，暂时先让客户使用其他浏览器登陆。直到今天公司销售部门也反馈了类似的问题，可以去实地排查原因了。 系统环境 win7 sp1 32位 浏览器 世界之窗极速版 在浏览器极速模式下是没有问题的，切换到兼容模式后字体图标就失踪了！所有双模式切换的浏览器的兼容模式归根结底还是调用的本机的IE，所以这还是IE的问题。 我们先是找到IE浏览器，因为是win7，所以最低也是IE8了。 更改Internet选项里的配置，无果！ 测试了链接字体图标库文件，也是正常的！ Win7视觉效果全开也没用！ F12添加行内字体样式也没作用！ 最后得出结论，这货就是根本不识别字体样式啊！这货打开的任何一个网页都是宋体，难道字体库只有宋体吗？可为什么极速模式字体就正常呢？win+R -&gt; fonts 发现所有系统自带字体都安安静静的躺着呢。 再次打开 Internet选项 -&gt; 外观 -&gt; 字体 -&gt; 微软雅黑，所有页面字体都变成微软雅黑了。然并卵！ 不经意间 Internet选项 -&gt; 外观 -&gt; 辅助功能…我滴个神！我看到什么了？ 原来是把网页字体忽略了！也是第一次知道IE还是这些设置选项，还可以定义用户样式。这次也算是长见识了。","tags":[{"name":"html","slug":"html","permalink":"http://imys.net/tags/html/"}]},{"title":"css3选择器(:target)用法","date":"2015-06-29T00:57:17.000Z","path":"20150629/css3-target-selector.html","text":"target译为“目标”，加冒号即为伪类选择器。此选择器便是用于给目标元素添加额外样式，类似于hover。 使用该选择对应的目标元素为锚点触发。以下代码定义了两个a元素，其中一个为链接元素，另一个使用样式定义为块元素。块元素设置了透明度为0，并设置其被链接时透明度为1和过度效果。最终的效果为点击链接元素时，div1从透明到不透明过度。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;target选择器&lt;/title&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;style&gt; .link &#123; display: block; text-decoration: none; text-align: center; color: #fff; background: #ff0000; line-height: 30px; &#125; .a-block &#123; display: block; opacity: 0; &#125; .a-block:target &#123; opacity: 1; transition: all .3s; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#div1\" class=\"link\"&gt;显示&lt;/a&gt; &lt;a id=\"div1\" class=\"a-block\"&gt; :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 :target选择器可用于当前活动的target元素的样式。 &lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 注意起初我写下这段Demo时目标元素是用的div，后来发现该选择器不能像:hover一样作用于a以外的元素。另外该选择器的兼容性为IE8以上（不包括IE8）。 适用场景结合这个Demo可以发现该选择器又一次实现之前需要JS才能实现的功能，比如点击链接显示元素。另外在全屏滚动动画页面时也可以用在导航之上，比如点击导航给对应的块添加动画效果。更多使用方法也待慢慢摸索了！","tags":[{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"}]},{"title":"HTML5页面可见性改变事件","date":"2015-06-15T03:01:53.000Z","path":"20150615/js-page-visible.html","text":"通过该事件可以判断当前页面对于用户的可见性，即返回用户当前浏览的页面或标签的状态变化。 visibilitychange（页面可见性改变事件）该事件属于HTML5新API，兼容性IE10+，以及其他现代浏览器等。 以下是一个简单的案例，当用户离开当前页面时改变页面标题。 var pageVisible = (function()&#123; var title = ''; var change = function() &#123; document.addEventListener('visibilitychange', function() &#123; var temp = this.title; this.title = title; title = temp; &#125;) &#125; return &#123; init: function(tit)&#123; title = tit || '好好学习，天天向上！'; change(); &#125; &#125;;&#125;)();pageVisible.init(); 此外，还可以在事件内对页面可见性属性判断可见性状态。 document.hidden: Boolean值，表示当前页面可见还是不可见。 适用场景，如： 1.用户离开媒体页面停止播放媒体；2.用户离开游戏页面暂停游戏；3.等等……","tags":[{"name":"html5","slug":"html5","permalink":"http://imys.net/tags/html5/"},{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"js阻止子元素响应父元素事件","date":"2015-05-27T12:44:34.000Z","path":"20150527/js-cancel-event.html","text":"今天同事遇到这样一个问题，找我解决。他希望点击整个DIV都可以响应点击事件，但是有些交互元素需要排除掉。如：点击链接页面跳转、点击按钮响应事件等）。这是一个关于事件冒泡的问题，那便从事件冒泡写起。 事件冒泡在一个元素上触发事件，如果此元素定义了处理程序，那么此次事件就会被捕获，根据程序进行该事件的处理。否则这个事件会根据DOM树向父节点逐级传播，如果从始至终都没有被处理，那么最终会到达document或window根元素。 阻止事件冒泡W3C标准调用事件对象的stopPropagation()方法，IE可以设置对象的cancelBubble属性为true; 在Jquery中的事件方法都带有event参数，这是一个符合W3C标准的事件对象，且兼容IE，可以使用event.stopPropagation()阻止冒泡。更简单的，直接return false;，等价于event.stopPropagation()加上event.preventDefault()。 在原生JS中，事件对象要区别对待。 function cancelEvent(e) &#123; if(e) &#123; e.stopPropagation(); //非IE &#125; else &#123; window.event.cancelBubble = true; //IE &#125;&#125; 阻止多个子元素的事件综上所述，想要链接和按钮元素不响应父节点事件，便要为所有这些元素注册事件，编写阻止事件冒泡的代码。 现在的代码可以这样写： var div = $('#div');div.click(function()&#123; // do...&#125;);div.on('click', 'a,button,input', function(event)&#123; event.stopPropagation(); // 或 return false;&#125;); 这当然是可以解决问题的。可对于处女座的我完全无法接受平白无故多写了一段莫名奇妙的代码。 于是我想到了event对象。 event.target 返回事件的目标节点（触发该事件的节点）。 event.target.tagName 目标节点的标签名 把上面两个事件合并处理之： $('#div').on('click', function(event)&#123; var tag = event.target.tagName; if(tag!='A' &amp;&amp; tag!='BUTTON' &amp;&amp; tag!='INPUT')&#123; // do... &#125;&#125;);","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"Hexo添加Toc支持，生成文章目录","date":"2015-05-14T07:25:47.000Z","path":"20150514/hexo-toc.html","text":"Hexo提供了诸多插件来增强博客体验，地址http://hexo.io/plugins/。在博客搬迁的时发现一个生成文章目录的插件，hexo-toc。 hexo-toc 为防插件误认标记，文章以下出现的 ttoc 实际为 toc。 使用方法跟显示文章摘要类似，在Markdown中需要显示文章目录的地方添加 &lt;!-- ttoc --&gt;。 安装npm install hexo-toc --save 配置在博客根目录下的 _config.yml 中如下配置： toc: maxDepth: 3 maxDepth 表示目录深度为3，即最多生成三级目录。 好了，现在重启Hexo预览下效果吧。 然后你会发现点击目录链接，没反应！F12查看生成的HTML代码： 标题id生成没问题，锚链接中的中文都被转义为 - 了。 看了该插件的issues中已经提到了这个问题，不过好像是没解决。也没用搜索到其他人有关该插件的使用经验。没办法，自己动手丰衣足食！ 解决锚链接中文被转义也没什么好的办法，只凭着入门级的Node水平，顺藤摸瓜！从插件下的index.js开始，一路跟踪代码调试，在感觉可能出现问题的地方console输出内容，最终让我给找到了。 文件位置：Hexo根目录\\node_modules\\hexo-toc\\node_modules\\markdown-toc\\index.js。找到如下方法，把原来返回值注释掉，直接 return str; 。 function slugify(str, opts) &#123; if (opts &amp;&amp; opts.slugify === false) return str; if (opts &amp;&amp; typeof opts.slugify === 'function') &#123; return opts.slugify(str, opts); &#125; str = str.split('.').join(''); //return str.toLowerCase().replace(/[^a-z0-9]/g, '-'); return str;&#125; 现在重启Hexo后链接都正常可用了。 更好的方法是不改变插件源代码的情况下进行配置。在以上方法中可以发现，插件有个slugify的配置项，当此项配置为false时即直接return str;。 所以，我们可以到_config.yml添加toc配置： toc: maxDepth: 3 slugify: false 给Toc添加样式如本文中文章目录样式，置于文章右侧，又加了个背景等。 hexo-toc插件是生成的文章目录最终还是Markdown格式的，最后被Hexo的marked模块解析为HTML。 要添加样式先加选择器。想通过修改插件代码增加选择器是行不通的，也不能直接在 &lt;!-- ttoc --&gt;标记外包裹 &lt;div&gt;。 因为添加了HTML标签的地方就不会在被marked模块解析。 那就只能在HTML生成之后增加，用js。 hexo-toc插件生成文章目录时还在其前后增加了 &lt;!-- ttoc --&gt; 和 &lt;!-- ttocstop --&gt; 注释。解决办法就是把这两个注释替换为可控的 &lt;div&gt;。 找到主题下的文章模版，我的是themes\\yilia\\layout\\_partial\\article.ejs。在其末尾增加代码： &lt;% if (!index &amp;&amp; theme.toc)&#123; %&gt;&lt;script&gt; var tocEx = function(el)&#123; var toc = document.querySelector(el), content = toc.innerHTML; content = content.replace(&apos;&lt;!-- ttoc --&gt;&apos;, &apos;&lt;div class=&quot;toc&quot;&gt;&apos;).replace(&apos;&lt;!-- ttocstop --&gt;&apos;, &apos;&lt;/div&gt;&apos;); toc.innerHTML = content; &#125;(&apos;.article-entry&apos;);&lt;/script&gt;&lt;% &#125; %&gt; 这样我们就为文章目录外包裹了一对&lt;div&gt;标签和一个toc类。 再写这个类的样式，放到主题下的相关css文件中。 .toc &#123; float: right; margin-left: 40px; padding: 10px 20px; background: #f1f1f1; border-radius: 10px; box-shadow: 0 0 3px #bbb;&#125; 这些都做完再次重启Hexo，成功！ 2016年更新Hexo 已经有生成文章目录的辅助函数了，使用更方便。我现在博客中的文章目录就是使用辅助函数生成的。 Hexo辅助函数#toc 不需要安装额外插件！不需要在文章中插入标记！不需要在配置文件添加配置！ 仅仅是在你的文章页模版中，插入调用辅助函数的代码即可。 &lt;%- toc(page.content, &#123; class: 'post-toc', list_number: true &#125;) %&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"}]},{"title":"博客搬迁记 - 从WordPress到Hexo","date":"2015-05-13T01:50:02.000Z","path":"20150513/wordpress-to-hexo.html","text":"今天早上打开电脑第一件事就是把pages绑定了域名，从此便可以使用http://imys.net进行访问了。 至此已经折腾的差不多了，在此记录下搬迁过程中遇到的一些问题及解决办法。 Hexo3本地部署现在node下安装的hexo一般都是最新版本，网上搜索到的一些教程不乏是老版本的，要特别留意。 参考 用Hexo 3 搭建github blog Hexo 3.0 静态博客使用指南 以上两篇文章应该能使你顺利的在http://localhost:4000/看到自己的新博客，并且你也熟悉了Hexo的常用命令。 Hexo无法解析模板文件本地预览页面显示： &lt;%- partial(&apos;_partial/head&apos;) %&gt; &lt;%- partial(&apos;_partial/header&apos;) %&gt; &lt;%- body %&gt; &lt;% if (theme.sidebar &amp;&amp; theme.sidebar !== &apos;bottom&apos;){ %&gt; &lt;%- partial(&apos;_partial/sidebar&apos;) %&gt; &lt;% } %&gt; &lt;%- partial(&apos;_partial/footer&apos;) %&gt; &lt;%- partial(&apos;_partial/mobile-nav&apos;) %&gt; &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt; 在工程目录执行下面3个命令，高版本的hexo移除默认的ejs。 $ npm install hexo-renderer-ejs --save $ npm install hexo-renderer-stylus --save $ npm install hexo-renderer-marked --save 上传到GitCafe 注册GitCafe创建Page项目 安装和设置 Git 以上两篇内容结合着看，不过对第一次操作这些的人来说可能会遇到一些问题。 生成SSH当命令窗口出现以下信息时，需要你输入passphrase口令。不过在我操作时输入口令的话是无法生成成功的，直接按enter即可。 Enter passphrase (empty for no passphrase): 设置git第一次在本地设置git时，需设置用户标识。 $ git config --global user.name &quot;yourname&quot; //gitcafe上的用户名 $ git config --global user.email &quot;yourmaill@yourmaili.com&quot; //填写自己的邮箱 设置本地gitcafe-pages版本库 GitBash进入本地Hexo目录 git checkout -b gitcafe-pages 创建Gitcafe-Pages分支，并切换到该分支。 git add . （.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。 上传到gitcafe修改hexo配置文件，即config.yml，如下配置： deploy: type: git repository: git@gitcafe.com:yourname/yourname.git branch: gitcafe-pages yourname 修改成你的用户名，如我的是：git@gitcafe.com:justgo/justgo.git 保存后直接在GitBash中hexo g &amp;&amp; hexo d上传即可（我在这一步折腾了很久，在cmd下运行hexo d命令会出错）。 稍等片刻，打开 http://youname/gitcafe.io 便可以看到自己的博客了。 WordPress文章迁移WordPress 后台可以直接导出wordpress.xml文件，把这个文件放入你的本地Hexo目录下，然后安装一个插件可以直接生成每篇文章的Markdown文件。 npm install hexo-migrator-wordpress --save //安装插件 hexo migrate wordpress wordpress.xml //生成Markdown 生成后的文件稍微修改一下格式就可以上传了。 庆幸的是我博客里的图片不多，不需要太多的链接修改。 不过以后我也开始使用七牛存储了，免得以后搬迁麻烦。 Hexo配置优化参考 hexo博客的配置、使用 hexo博客的优化技巧 hexo博客的优化技巧续 Hexo 优化与定制(一) Hexo 优化与定制(二) 无法开启RSS和sitemap打开http://localhost:4000/atom.xml 页面显示 Cannot GET atom.xml，http://localhost:4000/sitemap.xml 页面显示 Cannot GET sitemap.xml。 这个问题困扰了我很长的时间，因为我的插件安装和配置都是照着示例分毫不差的进行的，可是google了几个小时都没解决！ 插件也重装更新了几次，想过重新初始化Hexo，怕会丢失原来的一些配置，最后在 hexo/package.json 中找到了原因。 package.json： { &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.0.1&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.0.0&quot;, &quot;hexo-admin&quot;: &quot;^0.3.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.0.4&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.1.0&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.0.1&quot;, &quot;hexo-generator-sitemap&quot;: &quot;^1.0.1&quot;, &quot;hexo-migrator-wordpress&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.1.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.4&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.2.0&quot;, &quot;hexo-server&quot;: &quot;^0.1.2&quot; } } 检查此文件中是否包括了hexo-generator-tag和hexo-generator-sitemap，没有的话添加一下。插件版本号查看对应插件下的package.json文件，其他插件的类似问题应该也可以尝试这样解决。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://imys.net/tags/Hexo/"},{"name":"WordPress","slug":"WordPress","permalink":"http://imys.net/tags/WordPress/"},{"name":"gitcafe","slug":"gitcafe","permalink":"http://imys.net/tags/gitcafe/"}]},{"title":"jQuery.proxy方法原理与使用","date":"2015-05-09T16:25:13.000Z","path":"20150510/jquery-proxy.html","text":"在写一些jq插件时，往往需要在回调函数上下文中注入调用者对象，也就是改变函数上下文中 this 的引用。 从jQuery 1.4 开始便可以使用 jQuery.proxy 方法解决这个问题。 定义和用法$.proxy 方法接受一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文指向不同对象的元素添加事件。 提示：如果您绑定从 $.proxy 返回的函数，jQuery 仍然可以通过传递的原先的函数取消绑定正确的函数。 语法// 1$(selector).proxy(function,context);// 2$(selector).proxy(context,name); 实例// 用例1var obj1 = function()&#123; this.txt = \"helloWorld\"; $(document).click(this.fn);&#125;;var obj2 = function()&#123; this.txt = \"helloWorld\"; $(document).click($.proxy(this.fn, this));&#125;;obj1.prototype.fn = obj2.prototype.fn = function() &#123; console.log(this.txt);&#125;;var a = new obj1(); // undefinedvar b = new obj2(); // helloWorld// 用例2var dialog = &#123; msg: 'helloWorld', show: function () &#123; console.log(this); console.log(this.msg); &#125;&#125;$(document).click(dialog.show); // #document// undefined$(document).click($.proxy(dialog, \"show\")); // Object &#123;msg: \"helloWorld\", show: function&#125;// helloWorld 未使用 jQuery.proxy 方法时，click 方法中 this 指向为执行 click 方法的 jQuery 对象；使用 jQuery.proxy 方法时，click 方法中 this 指向为你所期望的对象。 原理不难猜出其底层实现应该是原生 js 中的 call 或 apply 方法。 jquery1.9 中的源码片段： proxy: function( fn, context ) &#123; var args, proxy, tmp; if ( typeof context === \"string\" ) &#123; tmp = fn[ context ]; context = fn; fn = tmp; &#125; // Quick check to determine if target is callable, in the spec // this throws a TypeError, but we will just return undefined. if ( !jQuery.isFunction( fn ) ) &#123; return undefined; &#125; // Simulated bind args = core_slice.call( arguments, 2 ); proxy = function() &#123; return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) ); &#125;; // Set the guid of unique handler to the same of original handler, so it can be removed proxy.guid = fn.guid = fn.guid || jQuery.guid++; return proxy;&#125;","tags":[{"name":"jquery","slug":"jquery","permalink":"http://imys.net/tags/jquery/"}]},{"title":"javascript中with语句用法","date":"2015-05-08T03:16:52.000Z","path":"20150508/javascript-with.html","text":"with 语句可以方便地用来引用某个特定对象中已有的属性或方法，但是不能用来给对象添加新的属性或方法。要给对象创建新的属性，必须明确地引用该对象。 用法function Student()&#123; this.name = &apos;jeck&apos;; this.age = 20; this.gender = &apos;men&apos;;&#125;var stu = new Student();with(stu) &#123; console.log(&apos;姓名：&apos; + name + &apos;，性别：&apos; + gender + &apos;，年龄：&apos; + age); // 姓名：jeck，性别：men，年龄：20&#125; 总结 with 语句使代码更简洁、易读。由于 with 会根据目标对象产生一个新的可变对象，推入作用域链的头部，这样原有的可访问对象都被往后推了一个层次，这使得它们的访问代价更高了。因此对于 with 语句最好避免使用。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"图片上传本地预览jquery插件","date":"2015-05-07T10:11:00.000Z","path":"20150507/jqplugin-uploadpreview.html","text":"网上找到的一段代码，经过一番测试修改，兼容了IE7+、火狐、谷歌。 并且扩展了多尺寸预览功能，可完美搭配 jquery.Jcrop 插件进行图像裁剪。 插件代码(function($) { jQuery.fn.extend({ uploadPreview: function(opts) { opts = jQuery.extend({ width: null, height: null, imgDiv: &quot;#imgDiv&quot;, anyTarget: null, maxSize: 300, imgType: [&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;bmp&quot;, &quot;png&quot;], callback: function() { return false; } }, opts || {}); var _this = $(this); var imgDiv = $(opts.imgDiv); opts.width &amp;amp;&amp;amp; imgDiv.width(opts.width); opts.height &amp;amp;&amp;amp; imgDiv.height(opts.height); var isIE = navigator.appName == &apos;Microsoft Internet Explorer&apos;, brVersion = navigator.appVersion, version; isIE &amp;amp;&amp;amp; (version = brVersion.split(&apos;;&apos;)[1].replace(/MSIE[ ]/g,&apos;&apos;).replace(&apos;.0&apos;,&apos;&apos;)); handle = function() { var img = imgDiv.find(&apos;img&apos;); opts.anyTarget &amp;amp;&amp;amp; $.each(opts.anyTarget.split(&apos;,&apos;), function(index, val) { $(val).html(img.clone()); }); img.width(opts.width).height(opts.height); opts.callback(img); }, createImg = function(){ imgDiv.html(&apos;&apos;); var img = $(&quot;&lt;img /&gt;&quot;); imgDiv.append(img); return img; }, _this.change(function() { if (this.value) { if (!RegExp(&quot;\\.(&quot; + opts.imgType.join(&quot;|&quot;) + &quot;)$&quot;, &quot;i&quot;).test(this.value.toLowerCase())) { alert(&quot;图片类型必须是&quot; + opts.imgType.join(&quot;，&quot;) + &quot;中的一种&quot;); this.value = &quot;&quot;; return false; } if (isIE &amp;amp;&amp;amp; version &lt; 10) { if (version == 6) { var image = new Image(); image.onload = function(){ if( (image.fileSize/1024) &gt; opts.maxSize) { alert(&apos;图片大小不能超过&apos;+opts.maxSize+&apos;K&apos;); return false; } } image.src = &apos;file:///&apos; + this.value; createImg().attr(&apos;src&apos;, image.src); handle(); } else { var img = document.selection.createRange().text || $(this).val(); var image = $(&apos;&lt;img /&gt;&apos;) image.load(function(){ if( (image.fileSize/1024) &gt; opts.maxSize) { alert(&apos;图片大小不能超过&apos;+opts.maxSize+&apos;K&apos;); return false; } }); image.attr(&apos;src&apos;, img); imgDiv.html(&apos;&apos;); image.css({ filter: &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=&apos;scale&apos;,src=&apos;&quot;+img+&quot;&apos;)&quot; }); imgDiv.append(image); setTimeout(handle, 100); } } else { var img; try{ var file = null; var size = 0; if(this.files &amp;amp;&amp;amp; this.files[0] ){ file = this.files[0]; size = file.size; }else if(this.files &amp;amp;&amp;amp; this.files.item(0)) { file = this.files.item(0); size = file.fileSize; } if((size/1024) &gt; opts.maxSize){ alert(&apos;图片大小不能超过&apos;+opts.maxSize+&apos;K&apos;); return false; } img = createImg(); //Firefox 因安全性问题已无法直接通过input[file].value 获取完整的文件路径 try{ //Firefox7.0 以下 img.attr(&apos;src&apos;, file.getAsDataURL()); }catch(e){ //Firefox8.0以上 img.attr(&apos;src&apos;, window.URL.createObjectURL(file)); } img.css({ &quot;vertical-align&quot;: &quot;middle&quot; }); setTimeout(handle, 100); }catch(e){ //支持html5的浏览器,比如高版本的firefox、chrome、ie10 if (this.files &amp;amp;&amp;amp; this.files[0]) { if((this.files[0].size/1024) &gt; opts.maxSize){ alert(&apos;图片大小不能超过&apos;+opts.maxSize+&apos;K&apos;); return false; } var reader = new FileReader(); reader.onload = function (e) { imgDiv.attr(&apos;src&apos;, e.target.result); }; reader.readAsDataURL(this.files[0]); setTimeout(handle, 100); } }; } } }); } }); })(jQuery); 参数 width: 图片容器宽度； height: 图片容器高度； imgDiv: 图片预览容器； anyTarget: 其他关联容器，多个容器逗号隔开； maxSize: 图片大小限制，单位KB； imgType: 图片类型限制； callback: 预览成功后的回调，参数 img(预览的图片节点，jquery类型)。 实例&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;title&gt;图片上传预览&lt;/title&gt; &lt;link href=&quot;http://cdn.bootcss.com/jquery-jcrop/0.9.12/css/jquery.Jcrop.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .fl { float: left; } .fr { float: right; } .logo-wrap { overflow: hidden; margin: 30px 0; } .logo-350, .logo-350 img { width: 350px; height: 350px; } .logo-350 { margin-right: 30px; } .logo-200, .logo-200 img { width: 200px; height: 200px; } .logo-200 { margin-bottom: 30px; } .logo-200-wrap { width: 200px; } .logo-100, .logo-100 img { width: 100px; height: 100px; } .logo-60, .logo-60 img { width: 60px; height: 60px; } .logo-350, .logo-200, .logo-100, .logo-60, .qrcode { border: 1px solid #ddd; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;file&quot; value=&quot;上传文件&quot; id=&quot;file&quot;&gt; &lt;div class=&quot;logo-wrap&quot;&gt; &lt;div class=&quot;fl logo-350&quot;&gt;&lt;/div&gt; &lt;div class=&quot;fl logo-200-wrap&quot;&gt; &lt;div class=&quot;logo-200&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div&gt; &lt;div class=&quot;fl logo-100&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;fr logo-60&quot;&gt;&lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://ysdn-wordpress.stor.sinaapp.com/js/jquery.uploadPreview.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;http://cdn.bootcss.com/jquery-jcrop/0.9.12/js/jquery.Jcrop.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; //&lt;![CDATA[ $(&quot;#file&quot;).uploadPreview({ width: 350, height: 350, imgDiv: &apos;.logo-350&apos;, anyTarget: &apos;.logo-200 .content, .logo-100 .content, .logo-60 .content&apos;, maxSize: 1024 * 2, callback: function(el) { var jOption = { setSelect: [75, 75, 275, 275], minSize: [200, 200], onChange: updatePreview, onSelect: updatePreview, aspectRatio: 1 }; var isIE = navigator.appName == &apos;Microsoft Internet Explorer&apos;, brVersion = navigator.appVersion, version; isIE &amp;amp;&amp;amp; (version = brVersion.split(&apos;;&apos;)[1].replace(/MSIE[ ]/g,&apos;&apos;).replace(&apos;.0&apos;,&apos;&apos;)); if (isIE &amp;amp;&amp;amp; version &lt; 10) { var api = $.Jcrop(el.selector, jOption); } else { el.Jcrop(jOption); } } }); function updatePreview(c) { if (parseInt(c.w) &gt; 0) { $(&apos;.logo-200, .logo-100, .logo-60&apos;).each(function(index, el) { var box = $(el), content = box.find(&apos;.content&apos;), img = content.find(&apos;img&apos;); content.width($(&apos;.logo-350&apos;).outerWidth()).height($(&apos;.logo-350&apos;).outerHeight()); var rx = box.width() / c.w; var ry = box.height() / c.h; img.css({ width: Math.round(rx * 350) + &apos;px&apos;, height: Math.round(ry * 350) + &apos;px&apos;, marginLeft: &apos;-&apos; + Math.round(rx * c.x) + &apos;px&apos;, marginTop: &apos;-&apos; + Math.round(ry * c.y) + &apos;px&apos; }); }); } } //]]&gt; &lt;/script&gt; &lt;/html&gt;","tags":[{"name":"jquery插件","slug":"jquery插件","permalink":"http://imys.net/tags/jquery插件/"},{"name":"jquery","slug":"jquery","permalink":"http://imys.net/tags/jquery/"}]},{"title":"javascript之arguments对象","date":"2015-04-29T03:55:20.000Z","path":"20150429/javascript-arguments.html","text":"在javascript中函数调用时，会自动在函数内产生一个arguments的隐藏对象。arguments类似于数组，但又不是数组。可以使用[]操作符获取函数调用时传递的实参。 其类型function test1()&#123; console.log(typeof arguments); // object&#125;test1(); 其属性length：获取函数内传入实参个数。适用场景：模拟函数重载。 function test2(a,b)&#123; console.log(arguments.length); // 获取函数内传入实参个数：4 console.log(test2.length); // 可以通过 函数名.length 获取形参个数：2&#125;test2(1, 'a', 5, 'gg'); callee：引用当前正在执行的函数。适用场景：递归。 // 求1到n的自然数之和function add(n)&#123; if(n == 1) return 1; else return n + arguments.callee(n-1);&#125; 转换成真正的数组Array.prototype.slice.call(arguments) // 任意数量的一组数字排序function mySort(a,b,v) &#123; var tags = new Array(); tags = tags.concat(tags.slice.call(arguments)).sort(function(a, b)&#123; return a - b; &#125;); return tags;&#125;var result = mySort(50,11,16,32,24,99,57,100);console.log(result); // [11, 16, 24, 32, 50, 57, 99, 100]","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"jQuery扩展 - 延迟执行hover事件","date":"2015-04-28T09:15:57.000Z","path":"20150428/jquery-delayHover.html","text":"适用场景如：鼠标随便一滑，无数个下拉菜单出来了，用户可能只是鼠标“打个酱油”罢了。 实现很简单，就是使用setTimeout延迟事件代码的执行。 (function($)&#123; function DelayHover(options) &#123; var defaults = &#123; speed : 400, // 延迟时间(毫秒) onHover : function(el) &#123;&#125;, // 鼠标悬浮 onOut : function(el)&#123;&#125; // 鼠标离开 &#125;; this.settings = $.extend(&#123;&#125;, defaults, options); var _this = this, hoverTimer; _this.bind = function () &#123; $(_this).hover(function() &#123; hoverTimer = setTimeout(function()&#123; _this.settings.onHover(_this); &#125;, _this.settings.speed); &#125;, function() &#123; clearTimeout(hoverTimer); _this.settings.onOut(_this); &#125;); &#125;; &#125; $.fn.delayHover = function(options) &#123; return this.each(function() &#123; DelayHover.call(this,options); this.bind(); &#125;); &#125;&#125;)(jQuery);","tags":[{"name":"jquery插件","slug":"jquery插件","permalink":"http://imys.net/tags/jquery插件/"},{"name":"jquery","slug":"jquery","permalink":"http://imys.net/tags/jquery/"}]},{"title":"使用css3后代选择器实现多背景色标签样式","date":"2015-04-25T19:09:06.000Z","path":"20150426/css3-selector-multiple-color.html","text":"css3增加了许多新的选择器，包括属性选择器、后代选择器和伪类选择器等，灵活运用可以做出很多出彩的效果。 在一些博客站点上经常会见到一些多背景色的标签样式，颜色固定为几种，按顺序循环呈现。 使用js迭代并添加不同的样式固然可行，不过css3为我们提供了更便捷的方法–后代选择器。 :nth-of-type(n)匹配同类型中的第n个同级兄弟元素。n可以是一个数字，一个关键字，或者一个公式。 实现这次的需求要使用公式代入的方式，nth-of-type(an+b)。a代表一个循环的大小，N是一个计数器（从0开始），以及b是偏移量。 假设我们需要4种标签颜色，就需要设置4个公式型的后代选择器，那么可以想到的第一个公式为4n+0，选取索引为4的倍数的元素。于是就可以推出剩余的3个公式为4n-1、4n-2、4n-3。 实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;使用css3子级选择器实现多颜色标签样式&lt;/title&gt;&lt;style type=\"text/css\"&gt; html &#123; background: #333; &#125; .tags &#123; width: 240px; margin: 150px auto; padding: 10px; background: #ddd; &#125; .tags&gt;a &#123; display: inline-block; text-decoration: none; color: #fff; padding: 5px 10px; margin: 0 5px 5px 0; border-radius: 3px; transition: all .5s; -webkit-transition: all .5s; &#125; .tags&gt;a:hover &#123; background: #666 !important; &#125; .tags&gt;a:nth-of-type(4n+0) &#123; background: #337AB7; &#125; .tags&gt;a:nth-of-type(4n-1) &#123; background: #5CB85C; &#125; .tags&gt;a:nth-of-type(4n-2) &#123; background: #5BC0DE; &#125; .tags&gt;a:nth-of-type(4n-3) &#123; background: #F0AD4E; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"tags\"&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;a href=\"\"&gt;html&lt;/a&gt; &lt;a href=\"\"&gt;css&lt;/a&gt; &lt;a href=\"\"&gt;javascript&lt;/a&gt; &lt;a href=\"\"&gt;jQuery&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"}]},{"title":"使用逻辑运算符 || && 简化javascript中if else选择结构","date":"2015-04-24T03:49:30.000Z","path":"20150424/js-simple-condition.html","text":"|| 和 &amp;&amp; 通常使用在条件表达式中，但是由于javascript语言的特殊性，这两个符号又被开发出了特别的使用技巧。 最基本的用法console.log(true &amp;amp;&amp;amp; true); // trueconsole.log(true &amp;amp;&amp;amp; false); // falseconsole.log(false &amp;amp;&amp;amp; true); // falseconsole.log(false &amp;amp;&amp;amp; false); // falseconsole.log(true || true); // trueconsole.log(true || false); // trueconsole.log(false || true); // trueconsole.log(false || false); // false 这是所有的编程语音通用的使用方法，毋庸置疑。 javascript中可以这么用var target, num;target = undefined || 'defaultValue'; // defaultValuenum = 0 || 1; // 1 你可以看成这样： var target;target = false || 'defaultValue'; // defaultValuenum = false || 1; // 1 因为在javascript中Object、function、非0的整数和字符串都为true，undefined、null和空字符串”” 为false。 但是javascript中却可以返回为true表达式的值，应该理解为“真值”和“假值”更贴切。 ‘||’在javascript中的规则：如果||左侧表达式的值为真值，则返回左侧表达式的值；否则返回右侧表达式的值。 console.log('真值'||''); // 真值console.log(undefined||object); // object ‘&amp;&amp;’在javascript中的规则：如果&amp;&amp;左侧表达式的值为真值，则返回右侧表达式的值；否则返回左侧表达式的值。 console.log(1 === 1 &amp;amp;&amp;amp; 2) // 2console.log(0 === 1 &amp;amp;&amp;amp; 2) // false 于是有了高逼格的javascript代码var n=1;((n === 1) &amp;amp;&amp;amp; (n = 3)) || ((n === 3) &amp;amp;&amp;amp; (n = 6)) || (n = 2); // 3((n === 1) &amp;amp;&amp;amp; (n = 3)) || ((n === 3) &amp;amp;&amp;amp; (n = 6)) || (n = 2); // 6((n === 1) &amp;amp;&amp;amp; (n = 3)) || ((n === 3) &amp;amp;&amp;amp; (n = 6)) || (n = 2); // 2//以上代码等价于if(n === 1) &#123; n = 3;&#125; else if(n === 3) &#123; n = 6;&#125; else &#123; n = 2;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"css3导航按钮图标样式切换效果","date":"2015-04-20T05:29:44.000Z","path":"20150420/css3-menu-style.html","text":"纯css实现的导航按钮图标样式切换效果，图标样式是css画出来的，再辅以css3动画效果。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;css3效果切换的导航按钮&lt;/title&gt;&lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding: 0; &#125; body &#123; background: #3B9DFF; &#125; .menuCtrl &#123; display: block; position: relative; border: 5px solid #fff; border-radius: 50%; width: 30px; height: 40px; padding: 20px 25px; margin: 150px auto; transition: all 0.25s ease-in-out; &#125; .menuCtrl .line &#123; width: 35px; height: 0; border-bottom: 5px solid #fff; position: relative; margin-left: -2px; transition: all 0.25s ease-in-out; &#125; .menuCtrl .line:nth-child(1) &#123; top: 10px; &#125; .menuCtrl .line:nth-child(2) &#123; top: 13px; &#125; .menuCtrl .line:nth-child(3) &#123; top: 16px; &#125; .menuCtrl:hover &#123; padding: 25px 30px; &#125; .menuCtrl:hover .line:nth-child(1) &#123; width: 20px; transform: rotateZ(-45deg) translateX(-3px) translateY(0px); &#125; .menuCtrl:hover .line:nth-child(2) &#123; width: 40px; &#125; .menuCtrl:hover .line:nth-child(3) &#123; width: 20px; transform: rotateZ(45deg) translateX(-3px) translateY(0px); &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"javascript:;\" class=\"menuCtrl\"&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;div class=\"line\"&gt;&lt;/div&gt; &lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css3","slug":"css3","permalink":"http://imys.net/tags/css3/"}]},{"title":"不链接页面在新窗口或标签页运行代码","date":"2015-04-15T01:58:21.000Z","path":"20150415/online-run-code.html","text":"在一些IT博客或者论坛都有在新窗口或标签页直接运行当前页面内代码的功能，但却不是像一些资源网站里的直接预览资源页面。这样动态的运行代码，无疑是节省了很大服务器空间。 前端网（W3Cfuns）就有这样的功能，用户可以直接运行博主笔记内的代码，问答论坛也一样。 查看了一下代码实现，原来是window.open()方法。 语法重温window.open(URL,name,features,replace) URL 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 &lt;a&gt; 和 &lt;form&gt; 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。在窗口特征这个表格中，我们对该字符串的格式进行了详细的说明。 replace 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 参数1URL省略会打开一个空白页，也就是about:blank页。不过window.open()方法居然是有返回值的，可以返回新页面的window对象。 如此的话，我们就能访问新页面的DOM，自然就可以写入代码了。 实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;新窗口或标签页运行代码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;textarea style=\"width:600px;height:150px;\" id=\"code\"&gt; &lt;script type=\"text/javascript\"&gt; document.write(\"&lt;h1&gt;我是运行在新窗口或标签页的代码。&lt;/h1&gt;\"); &lt;/script&gt;&lt;/textarea&gt;&lt;br&gt;&lt;button onclick=\"runCode()\"&gt;运行代码&lt;/button&gt;&lt;script type=\"text/javascript\"&gt; function runCode() &#123; var example = window.open('','',''); var code = document.getElementById('code').value; example.document.write(code) example.focus(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"js文本复制全兼容实例","date":"2015-04-14T06:00:45.000Z","path":"20150414/js-copytext.html","text":"对于文本复制本来就是右键-&gt;复制，或者Ctrl+C，很简单的事情。不过为了提升用户体验，就让我们找一个兼容性强的万全之策吧。 纯JS实现的方式不能兼容到现代浏览器，看了Discuz和bootstrap上代码复制的实现，发现都是借用Flash来实现的。 原理Flash可以操作剪贴板，用一个透明的Flash覆盖到一个DOM元素上。点击DOM实际是点击了Flash，从而操作剪贴板。 需要用到一个JavaScript库：Zero Clipboard，和一个Flash文件。另外要注意：页面必须在放到服务器上，本地没有Flash权限。 代码实例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;JS文本复制&lt;/title&gt;&lt;style type=\"text/css\"&gt; .box &#123; width: 610px; margin: 50px auto; position: relative; &#125; textarea &#123; width: 600px; height: 150px; padding: 5px; resize: none; border: 1px solid #ddd; outline: none; &#125; #copy-btn &#123; padding: 5px 8px; background: #F7F7F9; border: 1px solid #ddd; border-radius: 4px 0 0 0; position: absolute; right: -2px; margin-top: -30px; &#125; #clip-btn &#123; width: 80px; height: 40px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;h3&gt;JS文本复制实例&lt;/h3&gt; &lt;textarea placeholder=\"复制的内容区\" id=\"content\"&gt;&lt;/textarea&gt; &lt;button id=\"copy-btn\"&gt;点击复制&lt;/button&gt; &lt;/div&gt; &lt;div id=\"clip-btn\"&gt;&lt;/div&gt;&lt;script src=\"ZeroClipboard.js\"&gt;&lt;/script&gt; &lt;script&gt; var clip = null; // 设置Flash文件路径 ZeroClipboard.setMoviePath(\"ZeroClipboard.swf\"); function copyCode(text) &#123; clip = new ZeroClipboard.Client(); // 设置鼠标悬浮样式 clip.setHandCursor(true); // 点击复制 clip.addEventListener('mouseOver', function() &#123; clip.setText(text); &#125;); // 复制完成回调 clip.addEventListener( \"complete\", function()&#123; alert(\"复制成功！\"); clip.destroy(); //释放 &#125;); // Flash加载的目标容器 clip.glue('clip-btn'); &#125; /* js实现 */ function $(id) &#123; return document.getElementById(id); &#125; $('copy-btn').onmouseover = function(e) &#123; var clipBtn = $('clip-btn'); clipBtn.style.position = 'absolute'; clipBtn.style.left = (e.clientX -55 )+'px'; clipBtn.style.top = (e.clientY - 35)+'px'; copyCode($('content').value); &#125;; /*jQuery实现*/ // $('#copy-btn').mouseover(function() &#123; // var t = $(this); // var cobyText = t.prev().val(); // $('#clip-btn').css(&#123; // position: 'absolute', // left: t.offset().left, // top: t.offset().top, // zIndex: 999 // &#125;).mouseleave(function() &#123; // clip.destroy(); // &#125;); // copyCode(cobyText); // &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考文章：兼容主流浏览器的JS复制内容到剪贴板&#160;&#8617;","tags":[{"name":"javascript","slug":"javascript","permalink":"http://imys.net/tags/javascript/"}]},{"title":"CSS巧用border画小图形","date":"2015-04-09T13:26:50.000Z","path":"20150409/css-borde-shape.html","text":"css画三角形样式相信很多人都用过，比如 border-bottom设置宽度、颜色、实线，其他方向设置宽度和透明色就出现一个朝上的正三角形。 今天在看了 zyp199737 的笔记css3巧用border做翻页效果中一张图，突然想到设置2个方向是什么样式？是不是就是直角三角形呢？ 做了下实验，发现不止可以画出直角三角形，而且还有书签的样式。 代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;triangle&lt;/title&gt;&lt;style type=\"text/css\"&gt; .shape &#123; float: left; margin-left: 50px; width:0; height:0; border-width: 30px; border-style: dashed dashed dashed dashed ; border-color: transparent transparent transparent transparent ; &#125; /*三角形*/ .triangle &#123; border-bottom: 30px solid #e66161; &#125; /*标签*/ .mark &#123; border-left: 30px solid #e66161; border-top: 30px solid #e66161; border-right: 30px solid #e66161; &#125; /*直角三角形*/ .right-triangle &#123; border-left: 30px solid #e66161; border-bottom: 30px solid #e66161; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"shape triangle\"&gt;&lt;/div&gt; &lt;div class=\"shape mark\"&gt;&lt;/div&gt; &lt;div class=\"shape right-triangle\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"css","slug":"css","permalink":"http://imys.net/tags/css/"},{"name":"boder","slug":"boder","permalink":"http://imys.net/tags/boder/"}]},{"title":"jQuery实现通用的单页面锚点平滑滚动","date":"2015-04-07T05:45:03.000Z","path":"20150407/jquery-anchor-scroll.html","text":"很多商品展示页，专题页等都会用到。 代码&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;锚链接平滑滚动&lt;/title&gt;&lt;meta name=\"description\" content=\"\"&gt;&lt;meta name=\"keywords\" content=\"\"&gt;&lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0 &#125; html,body &#123; height: 100%; min-height: 100%; &#125; .top &#123; width: 100%; height: 40px; line-height: 40px; background: rgba(0, 0, 0, .6); position: fixed; z-index: 9; &#125; a &#123; color: #fff; text-align: center; text-decoration: none; &#125; .top a &#123; display: inline-block; width: 20%; &#125; .top a:hover &#123; background: rgba(0, 0, 0, .4); &#125; .page &#123; width: 100%; height: 100%; min-height: 100%; background: #3C98FF; text-align: center; &#125; h1 &#123; color: #fff; padding-top: 20%; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"top\"&gt; &lt;a href=\"#div-1\"&gt;div-1&lt;/a&gt; &lt;a href=\"#div-2\"&gt;div-2&lt;/a&gt; &lt;a href=\"#div-3\"&gt;div-3&lt;/a&gt; &lt;a href=\"#div-4\"&gt;div-4&lt;/a&gt; &lt;/div&gt; &lt;div id=\"div-1\" class=\"page\"&gt; &lt;h1&gt;第一页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-2\" class=\"page\"&gt; &lt;h1&gt;第二页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-3\" class=\"page\"&gt; &lt;h1&gt;第三页&lt;/h1&gt; &lt;/div&gt; &lt;div id=\"div-4\" class=\"page\"&gt; &lt;h1&gt;第四页&lt;/h1&gt; &lt;/div&gt;&lt;script src=\"http://libs.baidu.com/jquery/2.0.0/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $('a[href*=#]').click(function(event) &#123; // 此处正则用于转换带页面URL的锚点，如 http://abc.html#div,具体正则格式据实际情况而定 var targetId = $(this).attr('href').replace(/\\w+.html/,''); $(\"html,body\").animate(&#123;scrollTop: $(targetId).offset().top&#125;, 1000); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"jquery","slug":"jquery","permalink":"http://imys.net/tags/jquery/"}]}]