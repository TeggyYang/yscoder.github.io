{"title":"关于拖拽排序后的持久化方案","slug":"drag-the-sorted-field-design","date":"2017-02-24T07:09:00.000Z","updated":"2017-02-27T08:55:48.680Z","comments":true,"path":"api/articles/drag-the-sorted-field-design.json","excerpt":"<p>最近一次团队会议中提到了这个问题，感觉有点意思，就有了以下的思考。</p><p>我们可以很轻松的写出以下解决思路：</p><ol><li>每一项的数据模型都有一个字段<code>order</code>，表示排序的依据。</li><li>拖拽每一项后对<code>order</code>字段进行一定的变更，并发送修改请求，持久化排序字段。</li></ol><p>问题就在于第二步中的 <strong>进行一定的变更</strong>，是如何变更？<br>从这一点入手就出现了各种不同的解决方案。<br>","content":"<p>最近一次团队会议中提到了这个问题，感觉有点意思，就有了以下的思考。</p><p>我们可以很轻松的写出以下解决思路：</p><ol><li>每一项的数据模型都有一个字段<code>order</code>，表示排序的依据。</li><li>拖拽每一项后对<code>order</code>字段进行一定的变更，并发送修改请求，持久化排序字段。</li></ol><p>问题就在于第二步中的 <strong>进行一定的变更</strong>，是如何变更？<br>从这一点入手就出现了各种不同的解决方案。<br><a id=\"more\"></a></p><h2 id=\"取前后项差值除以2\"><a href=\"#取前后项差值除以2\" class=\"headerlink\" title=\"取前后项差值除以2\"></a>取前后项差值除以2</h2><p>这是原来旧项目中采用的方案。</p><ol><li>每一项数据初始化一个较大的<code>order</code>值，如：10000、20000、30000…</li><li>拖拽变化后，取前后项的<code>order</code>值相加除以<code>2</code>。假如把第三行拖拽到第一和第二行之间，那么它的<code>order</code>值由<code>30000</code>改为<code>(10000 + 20000) / 2</code>。</li></ol><p>理论上来讲，如果允许存在浮点数且不限制数据精度，绝对是可取的。退一步来说，也可以在数据临界时，或者某个空闲的时候依照当前顺序对数据库中的<code>order</code>列重新初始化。</p><p>这种方案的特点是：新的<code>order</code>值永远在前后项<code>order</code>值的区间内。</p><p>由这个特点可以衍生出一些方案，比如：<strong>降位法</strong>。</p><p>原始数据：</p><table><thead><tr><th>ID</th><th>order</th></tr></thead><tbody><tr><td>1cE2927ef1C6</td><td>1</td></tr><tr><td>8ea5Ed2687A6</td><td>1.1</td></tr><tr><td>2c70bADbe43C</td><td>2</td></tr><tr><td>16DA261B24F1</td><td>2.1</td></tr><tr><td>4Da27EE5d3de</td><td>2.2</td></tr><tr><td>8ea5Ed2687A6</td><td>2.3</td></tr><tr><td>65A64F9c12Ae</td><td>3</td></tr></tbody></table><p>把最后一项放到倒数第二项之前：</p><table><thead><tr><th>ID</th><th>order</th></tr></thead><tbody><tr><td>1cE2927ef1C6</td><td>1</td></tr><tr><td>8ea5Ed2687A6</td><td>1.1</td></tr><tr><td>2c70bADbe43C</td><td>2</td></tr><tr><td>16DA261B24F1</td><td>2.1</td></tr><tr><td>4Da27EE5d3de</td><td>2.2</td></tr><tr><td>65A64F9c12Ae</td><td>2.21</td></tr><tr><td>8ea5Ed2687A6</td><td>2.3</td></tr></tbody></table><p>由于<code>2.2</code>和<code>2.3</code>在十分位上不存在数的间隔，所以插入到之间的项降一位到百分位上。</p><h2 id=\"取前后项的ID\"><a href=\"#取前后项的ID\" class=\"headerlink\" title=\"取前后项的ID\"></a>取前后项的ID</h2><p>这是由链表数据结构想到的方案。每一项数据记录前一项或后一项的<code>ID</code>，拖拽变化后，进行对应的修改。</p><p><strong>缺点</strong>：</p><ol><li>数据渲染排序阶段开销大。假如取前一项<code>ID</code>为排序依据，需要找到前一项ID为<code>null</code>的为第一行数据，再找出前一项ID为第一行数据ID的为第二行数据…</li><li>前一项或后一项被删除，需要在删除数据的同时对受影响的排序字段进行数据修复，重新关联前一项或后一项的<code>ID</code>。</li></ol><p>简直可以当作使用链表的反面教材了。</p><h2 id=\"增加时间纬度\"><a href=\"#增加时间纬度\" class=\"headerlink\" title=\"增加时间纬度\"></a>增加时间纬度</h2><p>时间是列表排序中最常用的数据类型。一个列表在没有任何排序条件干涉的情况下，往往是按照创建时间进行排序的。<br>那么不如我们加个排序更新时间字段，作为相同<code>order</code>值之外的排序依据。</p><table><thead><tr><th>ID</th><th>order</th><th>orderUpdated</th></tr></thead><tbody><tr><td>d3fb1e8D5A3b</td><td>1</td><td>2017-02-27 16:28:46</td></tr><tr><td>7AeeEca1dbDA</td><td>2</td><td>2017-02-27 16:29:14</td></tr><tr><td>8EEccd9c99Cd</td><td>3</td><td>2017-02-27 16:29:28</td></tr></tbody></table><p>把第三行拖拽到第二行之前：</p><table><thead><tr><th>ID</th><th>order</th><th>orderUpdated</th></tr></thead><tbody><tr><td>d3fb1e8D5A3b</td><td>1</td><td>2017-02-27 16:28:46</td></tr><tr><td>8EEccd9c99Cd</td><td>1</td><td>2017-02-27 16:30:30</td></tr><tr><td>7AeeEca1dbDA</td><td>2</td><td>2017-02-27 16:29:14</td></tr></tbody></table><p><code>order</code>值与前一行相同的，再比较<code>orderUpdated</code>时间值，更新时间晚的居后。</p><p>这种方案应该称作：多维度排序。限于水平，目前我还举不出什么比时间纬度更好的例子。</p>","categories":[],"tags":[{"name":"drag","path":"api/tags/drag.json"},{"name":"sort","path":"api/tags/sort.json"},{"name":"db","path":"api/tags/db.json"}]}